<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CONTRIBUTING.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CONTRIBUTING.md" />
              <option name="updatedContent" value="# Contributing to PyCTools&#10;&#10;Thank you for your interest in contributing to PyCTools! This document provides guidelines for contributing to the project, including how to report bugs, suggest features, submit pull requests, and create releases.&#10;&#10;## Table of Contents&#10;&#10;- [Code of Conduct](#code-of-conduct)&#10;- [Bug Reports and Feature Requests](#bug-reports-and-feature-requests)&#10;- [Development Workflow](#development-workflow)&#10;- [Coding Standards](#coding-standards)&#10;- [Pull Request Process](#pull-request-process)&#10;- [Release Process](#release-process)&#10;&#10;## Code of Conduct&#10;&#10;Please read and follow our [Code of Conduct](CODE_OF_CONDUCT.md).&#10;&#10;## Bug Reports and Feature Requests&#10;&#10;If you encounter a bug or have a feature request, please open an issue on the [GitHub issue tracker](https://github.com/DefinetlyNotAI/PyCTools/issues).&#10;&#10;- **Bug Reports**: Include detailed steps to reproduce, expected behavior, actual behavior, and environment details.&#10;- **Feature Requests**: Clearly describe the feature, its use case, and potential implementation approach.&#10;&#10;## Development Workflow&#10;&#10;1. Fork the repository&#10;2. Create a new branch (`git checkout -b feature/amazing-feature`)&#10;3. Make your changes&#10;4. Test your changes&#10;5. Commit your changes (`git commit -m 'Add amazing feature'`)&#10;6. Push to the branch (`git push origin feature/amazing-feature`)&#10;7. Open a Pull Request&#10;&#10;## Coding Standards&#10;&#10;- Follow PEP 8 style guidelines for Python code&#10;- Write comprehensive docstrings for all functions and classes&#10;- Include type hints where appropriate&#10;- Write unit tests for new functionality&#10;- Comment complex code sections&#10;&#10;## Pull Request Process&#10;&#10;1. Ensure your code passes all tests and linting checks&#10;2. Update documentation as needed&#10;3. Add your changes to the CHANGELOG.md file&#10;4. Have at least one maintainer review and approve your PR&#10;&#10;## Release Process&#10;&#10;Creating a new release of PyCTools involves several steps to ensure proper packaging and distribution.&#10;&#10;### Pre-release Checklist&#10;&#10;1. Update version in `pyCTools/__init__.py`&#10;2. Update CHANGELOG.md&#10;3. Ensure all tests pass&#10;4. Update documentation if needed&#10;&#10;### Building the Package&#10;&#10;1. Run the setupHelper.py script to build the wheel package:&#10;   ```&#10;   python tool/setupHelper.py&#10;   ```&#10;&#10;2. This creates the wheel file in the `dist/wheels` directory and provides instructions for next steps.&#10;&#10;3. Run the distributionHelper.ps1 PowerShell script to prepare release files:&#10;   ```&#10;   pwsh tool/distributionHelper.ps1&#10;   ```&#10;&#10;4. This script:&#10;   - Creates the required `dist/x64` and `dist/x86` folder structure&#10;   - Copies DLL files with proper naming conventions&#10;   - Creates dist.zip containing the binary files&#10;   - Generates SHA256 hashes for verification&#10;   - Copies the wheel file to the dist folder&#10;&#10;### Creating the GitHub Release&#10;&#10;1. In the GitHub repository, go to &quot;Releases&quot; and click &quot;Create a new release&quot;&#10;&#10;2. Use the version tag suggested by setupHelper.py (e.g., `v1.0.0` or `0.2.0-beta`)&#10;&#10;3. Use the template from `tool/release.md` for the release description:&#10;   - Fill in the version number&#10;   - Add a descriptive title&#10;   - List key highlights and changes&#10;   - Include installation instructions&#10;&#10;4. Upload the three required files:&#10;   - `dist.zip` - The compressed archive with DLL files&#10;   - `dist.zip.sha256` - The hash verification file&#10;   - The wheel file (e.g., `pyctools-0.2.0b0-py3-none-any.whl`)&#10;&#10;5. Publish the release&#10;&#10;### Release Structure Requirements&#10;&#10;The release structure must follow this format:&#10;&#10;- The `dist.zip` file must contain:&#10;  - `x64/` folder with 64-bit DLLs named `name_x64.dll`&#10;  - `x86/` folder with 32-bit DLLs named `name_x86.dll`&#10;&#10;- The release notes must include:&#10;  - Installation instructions with the correct pip command&#10;  - Highlights of the changes&#10;  - Important notes about DLL structure requirements&#10;  - File descriptions table&#10;&#10;### Example Release Notes&#10;&#10;Follow the format in `tool/release.md` for consistent release notes.&#10;&#10;### Post-Release Tasks&#10;&#10;1. Announce the release on relevant channels&#10;2. Update documentation website if applicable&#10;3. Close related issues that were addressed in the release&#10;&#10;---&#10;&#10;Thank you for contributing to PyCTools!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.md" />
              <option name="updatedContent" value="# Python Hardware Random Number Generator (hwrng)&#10;&#10;## Overview&#10;&#10;The `pyCTools.hwrng` module provides Python bindings to the high-security hardware random number generation capabilities of the `hRng` library. This module allows Python applications to access cryptographically secure random numbers generated from multiple entropy sources including hardware RNG instructions when available.&#10;&#10;## Features&#10;&#10;- Cryptographically secure random number generation&#10;- Thread-safe operation&#10;- Support for high-intensity entropy gathering&#10;- Self-test capabilities&#10;- Automatic architecture detection (x86/x64)&#10;- Simple Python API with proper error handling&#10;&#10;## Installation&#10;&#10;The `pyCTools` package includes precompiled binaries for both x86 and x64 Windows platforms. No additional installation steps are needed beyond installing the package:&#10;&#10;```bash&#10;pip install pyCTools&#10;```&#10;&#10;## API Reference&#10;&#10;### Functions&#10;&#10;#### `get_hardware_random_bytes(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the standard MaxRNG algorithm.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate 32 random bytes&#10;random_data = get_hardware_random_bytes(32)&#10;print(&quot;Random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `get_hardware_random_bytes_threadsafe(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the thread-safe version of MaxRNG. This function is safe to call from multiple threads simultaneously.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;import threading&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def worker():&#10;    # Generate 16 random bytes in each thread&#10;    data = get_hardware_random_bytes_threadsafe(16)&#10;    print(f&quot;Thread {threading.current_thread().name}: {data.hex()}&quot;)&#10;&#10;# Create and start 5 threads&#10;threads = []&#10;for i in range(5):&#10;    t = threading.Thread(target=worker, name=f&quot;RNG-{i}&quot;)&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;#### `get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the extended MaxRNG algorithm with configurable entropy gathering intensity.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;- `intensive_level` (int, optional): Entropy gathering intensity level (must be &gt;= 1). Default is 2.&#10;  - Level 1: Standard MaxRNG operation&#10;  - Level 2: Additional CPU jitter entropy&#10;  - Level 3+: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive or intensive_level is less than 1&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;# Generate 64 random bytes with maximum entropy gathering&#10;random_data = get_hardware_random_bytes_extended(64, intensive_level=5)&#10;print(&quot;High-security random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `hardware_rng_selftest() -&gt; bool`&#10;&#10;Runs the built-in self-test for the RNG to verify proper operation.&#10;&#10;**Returns:**&#10;- `bool`: True if the self-test passes, False otherwise&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import hardware_rng_selftest&#10;&#10;if hardware_rng_selftest():&#10;    print(&quot;RNG self-test passed&quot;)&#10;else:&#10;    print(&quot;RNG self-test failed&quot;)&#10;```&#10;&#10;### Exceptions&#10;&#10;#### `HardwareRNGError`&#10;&#10;Raised when a hardware RNG operation fails or when the DLL cannot be loaded.&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes, HardwareRNGError&#10;&#10;try:&#10;    random_data = get_hardware_random_bytes(32)&#10;    print(&quot;Random bytes:&quot;, random_data.hex())&#10;except HardwareRNGError as e:&#10;    print(f&quot;RNG operation failed: {e}&quot;)&#10;```&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate a random 256-bit key (32 bytes)&#10;key = get_hardware_random_bytes(32)&#10;print(f&quot;Random 256-bit key: {key.hex()}&quot;)&#10;```&#10;&#10;### Using as a Source for cryptography Library&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;from cryptography.hazmat.primitives.asymmetric import rsa&#10;import os&#10;&#10;class HardwareRandomGenerator:&#10;    def __init__(self):&#10;        pass&#10;        &#10;    def read(self, size):&#10;        return get_hardware_random_bytes(size)&#10;&#10;# Use our hardware RNG as a source for RSA key generation&#10;os.environ[&quot;PYTHONHASHSEED&quot;] = &quot;0&quot;  # Fix seed for reproducible example&#10;rng = HardwareRandomGenerator()&#10;private_key = rsa.generate_private_key(&#10;    public_exponent=65537,&#10;    key_size=2048,&#10;    backend=default_backend(),&#10;    random_number_generator=rng&#10;)&#10;&#10;print(&quot;Generated RSA key with hardware entropy&quot;)&#10;```&#10;&#10;### High-Security Random Token Generation&#10;&#10;```python&#10;import base64&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;def generate_secure_token(length=32):&#10;    &quot;&quot;&quot;Generate a URL-safe, base64 encoded token with maximum entropy.&quot;&quot;&quot;&#10;    random_bytes = get_hardware_random_bytes_extended(length, intensive_level=5)&#10;    return base64.urlsafe_b64encode(random_bytes).decode('utf-8')&#10;&#10;# Generate a secure session token&#10;session_token = generate_secure_token(48)&#10;print(f&quot;Secure session token: {session_token}&quot;)&#10;```&#10;&#10;### Thread Safety Demonstration&#10;&#10;```python&#10;import threading&#10;import time&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def intensive_rng_task(thread_id):&#10;    &quot;&quot;&quot;Generate multiple random values in a thread.&quot;&quot;&quot;&#10;    for i in range(5):&#10;        data = get_hardware_random_bytes_threadsafe(16)&#10;        hex_data = data.hex()&#10;        print(f&quot;Thread {thread_id}, iteration {i}: {hex_data}&quot;)&#10;        time.sleep(0.01)  # Small delay to better visualize concurrent execution&#10;&#10;# Create and start 10 threads&#10;threads = []&#10;for i in range(10):&#10;    t = threading.Thread(target=intensive_rng_task, args=(i,))&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;## Technical Details&#10;&#10;### DLL Loading&#10;&#10;The module automatically locates and loads the appropriate version (x86 or x64) of the `hRng` DLL from the distribution directory. The DLL is loaded only once when the module is first imported.&#10;&#10;### Error Handling&#10;&#10;All RNG operations include proper error checking. If an operation fails, a `HardwareRNGError` exception is raised with an informative error message.&#10;&#10;### Thread Safety&#10;&#10;The `get_hardware_random_bytes_threadsafe` function uses the thread-safe version of the RNG which employs proper synchronization mechanisms to ensure safe concurrent access from multiple threads.&#10;&#10;### Performance Considerations&#10;&#10;- The standard `get_hardware_random_bytes` function provides the best balance of security and performance for most applications.&#10;- The `get_hardware_random_bytes_extended` function with higher intensity levels will be slower but provides additional entropy gathering.&#10;- For applications requiring many random numbers in performance-sensitive contexts, consider generating larger batches less frequently.&#10;&#10;## Security Recommendations&#10;&#10;1. Use `get_hardware_random_bytes_extended` with a high intensity level (4 or 5) for generating cryptographic keys and other highly sensitive values.&#10;2. Use `get_hardware_random_bytes_threadsafe` in multi-threaded applications to ensure thread safety.&#10;3. Consider running `hardware_rng_selftest()` at application startup to verify RNG functionality.&#10;4. For cryptographic applications, combine this RNG with proper key derivation functions (KDFs) such as PBKDF2 or Argon2.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;&#10;    dll = ctypes.CDLL(dll_path)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once&#10;_MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        raise HardwareRNGError(&quot;Thread-safe RNG implementation not available&quot;)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_IsRNGThreadSafe())&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;import threading&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;# Global lock for Python-level thread safety&#10;_py_lock = threading.Lock()&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        # Try looking for the DLL in the current directory as a fallback&#10;        current_dir = os.path.abspath(os.getcwd())&#10;        fallback_path = os.path.join(current_dir, dll_name)&#10;        if os.path.exists(fallback_path):&#10;            dll_path = fallback_path&#10;        else:&#10;            dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;            raise HardwareRNGError(f&quot;Could not find {dll_name}. Searched in {', '.join(possible_dist_paths)}&quot;)&#10;&#10;    try:&#10;        dll = ctypes.CDLL(dll_path)&#10;    except Exception as e:&#10;        raise HardwareRNGError(f&quot;Failed to load {dll_path}: {str(e)}&quot;)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once in a thread-safe way&#10;try:&#10;    _MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;except HardwareRNGError as e:&#10;    # Provide stubs for functions in case the DLL couldn't be loaded&#10;    def _error_stub(*args, **kwargs):&#10;        raise HardwareRNGError(&quot;RNG functions unavailable - DLL could not be loaded&quot;)&#10;    &#10;    _MaxRNG = _MaxRNG_Extended = _RNG_SelfTest = _IsRNGThreadSafe = _error_stub&#10;    print(f&quot;WARNING: Failed to load RNG DLL: {str(e)}&quot;)&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    # Add Python-level thread safety as a backup&#10;    with _py_lock:&#10;        buffer = (ctypes.c_ubyte * size)()&#10;        success = _MaxRNG(buffer, size)&#10;        if not success:&#10;            raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;        &#10;        # Make a copy to ensure buffer is fully processed before releasing the lock&#10;        return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        # Fall back to Python-level locking if C-level thread safety is not available&#10;        return get_hardware_random_bytes(size)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return bool(_IsRNGThreadSafe())&#10;    except Exception:&#10;        return False&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/t.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/t.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create&#10;    num_threads = 20&#10;    iterations_per_thread = 30&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                })&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.001)&#10;&#10;            except HardwareRNGError as e:&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                })&#10;                if use_thread_safe:&#10;                    nonlocal threadsafe_failures&#10;                    threadsafe_failures += 1&#10;                else:&#10;                    nonlocal standard_failures&#10;                    standard_failures += 1&#10;                break&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    for i in range(num_threads):&#10;        t = threading.Thread(&#10;            target=worker_thread,&#10;            args=(i, False, standard_results)&#10;        )&#10;        standard_threads.append(t)&#10;        t.start()&#10;&#10;    for t in standard_threads:&#10;        t.join()&#10;&#10;    standard_time = time.time() - start_time&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, True, threadsafe_results)&#10;            )&#10;            threadsafe_threads.append(t)&#10;            t.start()&#10;&#10;        for t in threadsafe_threads:&#10;            t.join()&#10;&#10;        threadsafe_time = time.time() - start_time&#10;&#10;    # Print results summary&#10;    print(&quot;\nResults Summary:&quot;)&#10;    print(&quot;--------------&quot;)&#10;    print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;    print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;    print(f&quot;  - Failures: {standard_failures}&quot;)&#10;    print(f&quot;  - Avg time per operation: {standard_time / len(standard_results):.6f}s&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;        print(f&quot;  - Avg time per operation: {threadsafe_time / len(threadsafe_results):.6f}s&quot;)&#10;&#10;        # Performance comparison&#10;        if standard_time &gt; 0 and threadsafe_time &gt; 0:&#10;            relative_perf = standard_time / threadsafe_time&#10;            if relative_perf &gt; 1:&#10;                print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;            else:&#10;                print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create - reduce count to avoid overloading&#10;    num_threads = 10&#10;    iterations_per_thread = 10&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run with proper exception handling&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;                &#10;                # Store result safely&#10;                result_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                }&#10;                &#10;                # Use thread lock for updating shared data&#10;                with threading.Lock():&#10;                    results_list.append(result_entry)&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.005)  # Slightly longer sleep to reduce contention&#10;&#10;            except Exception as e:&#10;                error_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                }&#10;                &#10;                with threading.Lock():&#10;                    results_list.append(error_entry)&#10;                    if use_thread_safe:&#10;                        nonlocal threadsafe_failures&#10;                        threadsafe_failures += 1&#10;                    else:&#10;                        nonlocal standard_failures&#10;                        standard_failures += 1&#10;                &#10;                # Don't break - let thread continue trying other iterations&#10;                time.sleep(0.01)  # Sleep a bit after error&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    &#10;    # Create threads with proper error handling&#10;    try:&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, False, standard_results),&#10;                name=f&quot;Std-Thread-{i}&quot;&#10;            )&#10;            standard_threads.append(t)&#10;            t.start()&#10;            # Brief sleep between thread starts&#10;            time.sleep(0.01)&#10;            &#10;        print(f&quot;Started {len(standard_threads)} standard threads&quot;)&#10;            &#10;        # Join with timeout to prevent hanging&#10;        for t in standard_threads:&#10;            t.join(timeout=10.0)  # 10 second timeout per thread&#10;            if t.is_alive():&#10;                print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                &#10;    except Exception as e:&#10;        print(f&quot;Error during standard thread execution: {str(e)}&quot;)&#10;&#10;    standard_time = time.time() - start_time&#10;    print(f&quot;Standard thread test completed in {standard_time:.2f} seconds&quot;)&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        &#10;        try:&#10;            for i in range(num_threads):&#10;                t = threading.Thread(&#10;                    target=worker_thread,&#10;                    args=(i, True, threadsafe_results),&#10;                    name=f&quot;Safe-Thread-{i}&quot;&#10;                )&#10;                threadsafe_threads.append(t)&#10;                t.start()&#10;                # Brief sleep between thread starts&#10;                time.sleep(0.01)&#10;                &#10;            print(f&quot;Started {len(threadsafe_threads)} thread-safe threads&quot;)&#10;                &#10;            # Join with timeout to prevent hanging&#10;            for t in threadsafe_threads:&#10;                t.join(timeout=10.0)&#10;                if t.is_alive():&#10;                    print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                    &#10;        except Exception as e:&#10;            print(f&quot;Error during thread-safe thread execution: {str(e)}&quot;)&#10;&#10;        threadsafe_time = time.time() - start_time&#10;        print(f&quot;Thread-safe test completed in {threadsafe_time:.2f} seconds&quot;)&#10;&#10;    # Print results summary - only if we have any results&#10;    if standard_results:&#10;        print(&quot;\nResults Summary:&quot;)&#10;        print(&quot;--------------&quot;)&#10;        print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {standard_failures}&quot;)&#10;        if standard_results:&#10;            print(f&quot;  - Avg time per operation: {standard_time / max(len(standard_results), 1):.6f}s&quot;)&#10;&#10;        if thread_safe_available and threadsafe_results:&#10;            print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;            print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;            print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;            print(f&quot;  - Avg time per operation: {threadsafe_time / max(len(threadsafe_results), 1):.6f}s&quot;)&#10;&#10;            # Performance comparison&#10;            if standard_time &gt; 0 and threadsafe_time &gt; 0 and len(standard_results) &gt; 0 and len(threadsafe_results) &gt; 0:&#10;                relative_perf = standard_time / threadsafe_time&#10;                if relative_perf &gt; 1:&#10;                    print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;                else:&#10;                    print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;    else:&#10;        print(&quot;\nNo results collected! Test failed to run properly.&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available and threadsafe_results:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/Overview.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/Overview.md" />
              <option name="originalContent" value="# PyCTools Library Documentation&#10;&#10;## Overview&#10;&#10;PyCTools is a high-performance Python library that provides native C-backed functionality for system-level operations that require maximum performance and direct hardware access. The library bridges Python's ease of use with C's raw performance through carefully designed wrapper classes.&#10;&#10;## Components&#10;&#10;The library currently consists of two main modules:&#10;&#10;1. **hwrng** - Hardware-based Random Number Generator that interfaces with CPU hardware to generate cryptographically secure random numbers at maximum performance.&#10;&#10;2. **processInspect** - Advanced process metrics collection system for detailed system and process monitoring with minimal overhead.&#10;&#10;## Key Strengths&#10;&#10;- **Native Performance**: Direct access to hardware and system resources via compiled C/C++ code&#10;- **Cross-Architecture Support**: Works on both x86 and x64 Windows environments&#10;- **Thread Safety**: Designed for concurrent operation in multithreaded environments&#10;- **Comprehensive Metrics**: Detailed process and system statistics beyond what's available in standard Python libraries&#10;- **Hardware RNG**: True random number generation using CPU hardware features&#10;- **Minimal Overhead**: Engineered to add negligible performance impact while monitoring&#10;&#10;## Usage Domains&#10;&#10;- Performance monitoring and diagnostics&#10;- Security applications requiring cryptographically secure random numbers&#10;- System administration and monitoring tools&#10;- Performance-critical scientific or financial applications&#10;&#10;Each module is documented in detail in its dedicated documentation file.&#10;&#10;" />
              <option name="updatedContent" value="# PyCTools Library Documentation&#10;&#10;## Overview&#10;&#10;PyCTools is a high-performance Python library that provides native C-backed functionality for system-level operations that require maximum performance and direct hardware access. The library bridges Python's ease of use with C's raw performance through carefully designed wrapper classes that interface with compiled native code.&#10;&#10;## Components&#10;&#10;The library currently consists of two main modules:&#10;&#10;1. **hwrng** - Hardware-based Random Number Generator that interfaces with CPU hardware to generate cryptographically secure random numbers at maximum performance. It utilizes the CPU's RDRAND instruction (where available) for true hardware randomness.&#10;&#10;2. **processInspect** - Advanced process metrics collection system for detailed system and process monitoring with minimal overhead. Provides comprehensive performance data for Windows processes beyond standard Python libraries.&#10;&#10;## Architecture&#10;&#10;PyCTools employs a hybrid architecture:&#10;&#10;- **Python Layer**: Clean, Pythonic wrapper classes providing a user-friendly API&#10;- **Native Layer**: High-performance C/C++ code compiled to architecture-specific DLLs&#10;- **Dynamic Loading**: Intelligent DLL loader that automatically selects the correct binary for the host architecture&#10;&#10;The library uses a centralized DLL loading mechanism through the `_loadDLL` module, which implements sophisticated path resolution and error handling to ensure reliable operation across different environments.&#10;&#10;## Key Strengths&#10;&#10;- **Native Performance**: Direct access to hardware and system resources via compiled C/C++ code&#10;- **Cross-Architecture Support**: Works seamlessly on both x86 and x64 Windows environments&#10;- **Thread Safety**: Designed for concurrent operation in multithreaded environments&#10;- **Comprehensive Metrics**: Detailed process and system statistics beyond what's available in standard Python libraries&#10;- **Hardware RNG**: True random number generation using CPU hardware features&#10;- **Minimal Overhead**: Engineered to add negligible performance impact while monitoring&#10;- **Robust DLL Management**: Intelligent DLL discovery and loading with clear error reporting&#10;- **Consistent API**: Uniform interface pattern across different modules for ease of use&#10;- **Detailed Documentation**: Comprehensive documentation with examples and best practices&#10;&#10;## Usage Domains&#10;&#10;- Performance monitoring and diagnostics&#10;- Security applications requiring cryptographically secure random numbers&#10;- System administration and monitoring tools&#10;- Performance-critical scientific or financial applications&#10;- Resource usage tracking and optimization&#10;- Application performance benchmarking&#10;&#10;Each module is documented in detail in its dedicated documentation file." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/hwrng.md" />
              <option name="originalContent" value="# Hardware Random Number Generator (hwrng) Module&#10;&#10;The OSS `/dev/urandom` of Windows.&#10;&#10;---&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hwrng.py&lt;/summary&gt;&#10;&#10;## hwrng.py&#10;&#10;&gt; This is not comprehensive at all&#10;&#10;### Features&#10;- Get cryptographically secure random bytes from hardware RNG (RDRAND).&#10;- Raises `HardwareRNGError` if not supported or DLL missing.&#10;&#10;### Usage&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;rb = get_hardware_random_bytes(32)&#10;print(rb.hex())&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;&#10;## Module Overview&#10;&#10;The `hwrng` module provides a Python interface to hardware-based random number generation capabilities through the `MaxRNG` class. This class wraps a native C library that accesses CPU hardware random number generation features to produce high-quality random data with superior entropy compared to software-based PRNGs.&#10;&#10;## MaxRNG Class&#10;&#10;### Class Description&#10;`MaxRNG` is a wrapper class for hardware-based random number generation that interfaces with a native DLL (`hRng_x64.dll` or `hRng_x86.dll` depending on architecture). It automatically detects the system architecture and loads the appropriate binary.&#10;&#10;### Initialization&#10;```python&#10;rng = MaxRNG()&#10;```&#10;When instantiating the class, it performs the following operations:&#10;- Determines system architecture (x86/x64)&#10;- Searches for the appropriate DLL in multiple possible paths&#10;- Loads the DLL using ctypes&#10;- Sets up function prototypes and return types&#10;&#10;### Constants&#10;The class does not expose any constants directly.&#10;&#10;### Methods&#10;&#10;#### `test_rng_available() -&gt; bool`&#10;&#10;Checks if the hardware random number generator is available on the current system.&#10;&#10;**Returns:**&#10;- `True` if hardware RNG is available&#10;- `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_rng_available():&#10;    print(&quot;Hardware RNG is available&quot;)&#10;else:&#10;    print(&quot;Hardware RNG is not available&quot;)&#10;```&#10;&#10;#### `test_threading_available() -&gt; bool`&#10;&#10;Checks if the thread-safe version of the RNG is available.&#10;&#10;**Returns:**&#10;- `True` if thread-safe RNG is available&#10;- `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    print(&quot;Thread-safe RNG is available&quot;)&#10;else:&#10;    print(&quot;Thread-safe RNG is not available&quot;)&#10;```&#10;&#10;#### `maxrng(size: int) -&gt; bytes`&#10;&#10;Generates random bytes using the hardware RNG.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng(32)  # Generate 32 random bytes&#10;```&#10;&#10;#### `maxrng_ultra(size: int, complexity: int) -&gt; bytes`&#10;&#10;Generates random bytes with additional complexity for enhanced security.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;- `complexity` (int): Level of additional entropy mixing (higher values provide potentially better randomness but slower performance)&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng_ultra(32, 3)  # Generate 32 random bytes with complexity level 3&#10;```&#10;&#10;#### `maxrng_threadsafe(size: int) -&gt; bytes`&#10;&#10;Thread-safe version of the random number generator.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If threading is not available or if the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    random_data = rng.maxrng_threadsafe(32)  # Generate 32 random bytes in thread-safe mode&#10;```&#10;&#10;### Implementation Details&#10;&#10;#### DLL Loading&#10;The class implements a sophisticated DLL search mechanism that looks in multiple relative paths:&#10;- `./dist/{arch}/hRng_{arch}.dll`&#10;- `../dist/{arch}/hRng_{arch}.dll`&#10;- `../../dist/{arch}/hRng_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;#### Error Handling&#10;All methods perform proper error checking of the underlying C functions and raise appropriate exceptions with detailed error messages when operations fail.&#10;&#10;#### Memory Management&#10;The class handles all memory allocation and deallocation for the buffer used to store random data, ensuring no memory leaks occur during operation.&#10;&#10;## Usage Best Practices&#10;&#10;1. **Always check availability before use:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_rng_available():&#10;       # Proceed with RNG operations&#10;   ```&#10;&#10;2. **For thread-safe operations:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_threading_available():&#10;       # Proceed with thread-safe RNG operations&#10;   ```&#10;&#10;3. **Handle potential exceptions:**&#10;   ```python&#10;   try:&#10;       random_data = rng.maxrng(32)&#10;   except RuntimeError as e:&#10;       # Handle failure&#10;   ```&#10;&#10;4. **Choose the appropriate method:**&#10;   - `maxrng()` for standard random number generation&#10;   - `maxrng_ultra()` for higher security requirements&#10;   - `maxrng_threadsafe()` for multithreaded applications&#10;&#10;" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hwrng) Module&#10;&#10;The OSS `/dev/urandom` of Windows.&#10;&#10;---&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hwrng.py&lt;/summary&gt;&#10;&#10;## hwrng.py&#10;&#10;&gt; This is not comprehensive at all&#10;&#10;### Features&#10;- Get cryptographically secure random bytes from hardware RNG (RDRAND).&#10;- Raises `HardwareRNGError` if not supported or DLL missing.&#10;&#10;### Usage&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;rb = get_hardware_random_bytes(32)&#10;print(rb.hex())&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;## Module Overview&#10;&#10;The `hwrng` module provides a Python interface to hardware-based random number generation capabilities through the `MaxRNG` class. This class wraps a native C library that accesses CPU hardware random number generation features (like Intel's RDRAND instruction) to produce high-quality random data with superior entropy compared to software-based PRNGs.&#10;&#10;## MaxRNG Class&#10;&#10;### Class Description&#10;`MaxRNG` is a wrapper class for hardware-based random number generation that interfaces with a native DLL (`hRng_x64.dll` or `hRng_x86.dll` depending on architecture). It automatically detects the system architecture and loads the appropriate binary through the centralized `_loadDLL` module.&#10;&#10;### Initialization&#10;```python&#10;rng = MaxRNG()&#10;```&#10;&#10;When instantiating the class, it performs the following operations:&#10;- Loads the appropriate DLL using the `load_dll` helper function:&#10;  - Determines system architecture (x86/x64) automatically&#10;  - Searches for the appropriate DLL in the standard distribution paths&#10;  - Configures the loader to use `ctypes.WinDLL` specifically for this module&#10;- Sets up ctypes function prototypes and return types for type safety:&#10;  - Defines appropriate argument types for all DLL functions&#10;  - Defines appropriate return types for all DLL functions&#10;&#10;### DLL Loading Details&#10;&#10;The `MaxRNG` class uses the centralized `load_dll` function with these parameters:&#10;- `dll_prefix_name=&quot;hRng&quot;`: Loads either `hRng_x64.dll` or `hRng_x86.dll` based on architecture&#10;- `dll_load_func=ctypes.WinDLL`: Uses WinDLL loader specifically for the Windows API functions used in this module&#10;&#10;The DLL search mechanism looks in these locations by default:&#10;- `./dist/{arch}/hRng_{arch}.dll`&#10;- `../dist/{arch}/hRng_{arch}.dll`&#10;- `../../dist/{arch}/hRng_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;### Methods&#10;&#10;#### `test_rng_available() -&gt; bool`&#10;&#10;Checks if the hardware random number generator is available on the current system.&#10;&#10;**Returns:**&#10;- `True` if hardware RNG is available&#10;- `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Calls the C function `test_rng_available()` in the DLL&#10;- Returns `True` if the function returns `1`, `False` otherwise&#10;- Does not throw exceptions, making it safe to use for feature detection&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_rng_available():&#10;    print(&quot;Hardware RNG is available&quot;)&#10;else:&#10;    print(&quot;Hardware RNG is not available&quot;)&#10;```&#10;&#10;#### `test_threading_available() -&gt; bool`&#10;&#10;Checks if the thread-safe version of the RNG is available.&#10;&#10;**Returns:**&#10;- `True` if thread-safe RNG is available&#10;- `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Calls the C function `test_threading_available()` in the DLL&#10;- Returns `True` if the function returns `1`, `False` otherwise&#10;- Does not throw exceptions, making it safe to use for feature detection&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    print(&quot;Thread-safe RNG is available&quot;)&#10;else:&#10;    print(&quot;Thread-safe RNG is not available&quot;)&#10;```&#10;&#10;#### `maxrng(size: int) -&gt; bytes`&#10;&#10;Generates random bytes using the hardware RNG.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng` with the buffer and size&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng(32)  # Generate 32 random bytes&#10;```&#10;&#10;#### `maxrng_ultra(size: int, complexity: int) -&gt; bytes`&#10;&#10;Generates random bytes with additional complexity for enhanced security.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;- `complexity` (int): Level of additional entropy mixing (higher values provide potentially better randomness but slower performance)&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng_ultra` with the buffer, size, and complexity level&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng_ultra(32, 3)  # Generate 32 random bytes with complexity level 3&#10;```&#10;&#10;#### `maxrng_threadsafe(size: int) -&gt; bytes`&#10;&#10;Thread-safe version of the random number generator.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If threading is not available or if the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- First checks if threading is available by calling `test_threading_available()`&#10;- If not available, raises a detailed RuntimeError with best practices advice&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng_threadsafe` with the buffer and size&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    random_data = rng.maxrng_threadsafe(32)  # Generate 32 random bytes in thread-safe mode&#10;```&#10;&#10;### Error Handling&#10;&#10;The class implements comprehensive error handling:&#10;&#10;- **Feature Detection**: Non-throwing methods `test_rng_available()` and `test_threading_available()` for safely detecting capabilities&#10;- **Operation Validation**: All generator methods check return values and raise descriptive exceptions&#10;- **Threading Safety Check**: The `maxrng_threadsafe()` method validates threading availability before attempting operations&#10;- **Detailed Error Messages**: Clear error messages when operations fail, including best practices advice&#10;&#10;### Memory Management&#10;&#10;The class handles all memory allocation and deallocation for the buffer used to store random data, ensuring no memory leaks occur during operation:&#10;&#10;- Uses properly sized ctypes buffers for each operation&#10;- Converts C buffers to Python bytes objects which are managed by Python's garbage collector&#10;- Ensures C memory is properly released after each operation&#10;&#10;## Usage Best Practices&#10;&#10;1. **Always check availability before use:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_rng_available():&#10;       # Proceed with RNG operations&#10;   ```&#10;&#10;2. **For thread-safe operations:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_threading_available():&#10;       # Proceed with thread-safe RNG operations&#10;   ```&#10;&#10;3. **Handle potential exceptions:**&#10;   ```python&#10;   try:&#10;       random_data = rng.maxrng(32)&#10;   except RuntimeError as e:&#10;       # Handle failure&#10;   ```&#10;&#10;4. **Choose the appropriate method:**&#10;   - `maxrng()` for standard random number generation&#10;   - `maxrng_ultra()` for higher security requirements&#10;   - `maxrng_threadsafe()` for multithreaded applications&#10;&#10;5. **Performance considerations:**&#10;   - `maxrng()` is the fastest method with basic hardware randomness&#10;   - `maxrng_ultra()` provides enhanced security at the cost of performance&#10;   - Lower complexity values in `maxrng_ultra()` offer better performance with reasonable security&#10;&#10;6. **Reuse the MaxRNG instance:**&#10;   ```python&#10;   # Create once, reuse multiple times&#10;   rng = MaxRNG()&#10;   &#10;   # Use in multiple places&#10;   data1 = rng.maxrng(32)&#10;   data2 = rng.maxrng(64)&#10;   ```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/pI.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/pI.md" />
              <option name="originalContent" value="# Process Inspection (processInspect) Module&#10;&#10;## Module Overview&#10;&#10;The `processInspect` module provides comprehensive process and system metrics collection capabilities through the `ProcessMetrics` class. This class interfaces with a native DLL to collect detailed metrics about Windows processes with minimal performance overhead, offering insights beyond what's available through standard Python libraries.&#10;&#10;## ProcessMetrics Class&#10;&#10;### Class Description&#10;`ProcessMetrics` is a wrapper class that interfaces with the native `processInspect` DLL to collect various system and process metrics on Windows systems. It supports both instant snapshots and time-span measurements for comprehensive performance analysis.&#10;&#10;### Initialization&#10;```python&#10;metrics = ProcessMetrics()&#10;```&#10;When instantiating the class, it:&#10;- Determines system architecture (x86/x64)&#10;- Searches for the appropriate DLL in multiple possible paths&#10;- Loads the DLL using ctypes&#10;- Sets up function prototypes and return types&#10;- Raises `FileNotFoundError` if the DLL cannot be found&#10;&#10;### Constants&#10;&#10;The class provides constants for selecting which metrics to collect:&#10;&#10;| Constant | Value | Description |&#10;|----------|-------|-------------|&#10;| `METRIC_WORKING_SET` | 0x01 | Memory currently in RAM (working set) |&#10;| `METRIC_PRIVATE_BYTES` | 0x02 | Memory exclusively allocated to the process |&#10;| `METRIC_PAGEFILE` | 0x04 | Memory usage in the pagefile |&#10;| `METRIC_HANDLES` | 0x08 | Number of handles open by the process |&#10;| `METRIC_THREADS` | 0x10 | Number of threads in the process |&#10;| `METRIC_CPU_USAGE` | 0x20 | CPU usage percentage |&#10;| `METRIC_IO` | 0x40 | I/O statistics (reads, writes) |&#10;| `METRIC_NET` | 0x80 | Network statistics |&#10;&#10;These constants can be combined using bitwise OR (`|`) to select multiple metrics.&#10;&#10;### Methods&#10;&#10;#### `start_session(pid: int, metrics: int) -&gt; bool`&#10;&#10;Starts a metrics collection session for a specific process.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to monitor&#10;- `metrics` (int): Bitmask of metrics to collect, using class constants&#10;&#10;**Returns:**&#10;- `bool`: `True` if session started successfully, `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;success = pm.start_session(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;)&#10;```&#10;&#10;#### `end_session(pid: int, metrics: int) -&gt; dict`&#10;&#10;Ends a previously started metrics collection session and retrieves results.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID of the session to end&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Metrics collected during the session, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;# Start session first&#10;pm.start_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;# ... do some work ...&#10;# End session and get results&#10;results = pm.end_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;```&#10;&#10;#### `get_snapshot(pid: int, metrics: int) -&gt; dict`&#10;&#10;Retrieves an instant snapshot of metrics for a process without starting a session.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Current metrics snapshot, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;snapshot = pm.get_snapshot(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | &#10;    ProcessMetrics.METRIC_WORKING_SET | &#10;    ProcessMetrics.METRIC_HANDLES&#10;)&#10;```&#10;&#10;### Return Value Structure&#10;&#10;All methods that return metrics provide a dictionary with the following structure (keys present depend on requested metrics):&#10;&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,                    // Process ID&#10;  &quot;name&quot;: &quot;example.exe&quot;,          // Process name&#10;  &quot;timestamp&quot;: 1629384756,        // Unix timestamp&#10;  &quot;duration&quot;: 5.23,               // Duration in seconds (for session metrics)&#10;  &quot;cpu_usage&quot;: {                  // If METRIC_CPU_USAGE requested&#10;    &quot;percent&quot;: 14.5,              // CPU usage percentage&#10;    &quot;kernel_time&quot;: 0.234,         // Time spent in kernel mode (seconds)&#10;    &quot;user_time&quot;: 1.456            // Time spent in user mode (seconds)&#10;  },&#10;  &quot;memory&quot;: {                     // Memory metrics&#10;    &quot;working_set&quot;: 123456789,     // If METRIC_WORKING_SET requested (bytes)&#10;    &quot;private_bytes&quot;: 98765432,    // If METRIC_PRIVATE_BYTES requested (bytes)&#10;    &quot;pagefile&quot;: 45678912          // If METRIC_PAGEFILE requested (bytes)&#10;  },&#10;  &quot;handles&quot;: 345,                 // If METRIC_HANDLES requested&#10;  &quot;threads&quot;: 12,                  // If METRIC_THREADS requested&#10;  &quot;io&quot;: {                         // If METRIC_IO requested&#10;    &quot;reads&quot;: 1234,                // Number of read operations&#10;    &quot;writes&quot;: 5678,               // Number of write operations&#10;    &quot;bytes_read&quot;: 12345678,       // Total bytes read&#10;    &quot;bytes_written&quot;: 87654321     // Total bytes written&#10;  },&#10;  &quot;network&quot;: {                    // If METRIC_NET requested&#10;    &quot;bytes_sent&quot;: 123456,         // Total bytes sent&#10;    &quot;bytes_received&quot;: 654321      // Total bytes received&#10;  }&#10;}&#10;```&#10;&#10;### Implementation Details&#10;&#10;#### DLL Loading&#10;The class implements a DLL search mechanism that looks in multiple relative paths:&#10;- `./dist/{arch}/processInspect_{arch}.dll`&#10;- `../dist/{arch}/processInspect_{arch}.dll`&#10;- `../../dist/{arch}/processInspect_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;#### Internal Helper Methods&#10;`_json_call(func, pid, metrics)`: Internal helper method that calls DLL functions returning JSON data, handles the buffer, parses the JSON, and returns the result as a Python dictionary.&#10;&#10;#### Error Handling&#10;All methods perform proper error checking and raise appropriate exceptions with detailed error messages when operations fail.&#10;&#10;## Usage Best Practices&#10;&#10;### Selecting the Right Method&#10;&#10;- **For a single point-in-time measurement:**&#10;  ```python&#10;  snapshot = metrics.get_snapshot(pid, metrics_flags)&#10;  ```&#10;&#10;- **For measuring performance over time:**&#10;  ```python&#10;  metrics.start_session(pid, metrics_flags)&#10;  # ... time passes ...&#10;  results = metrics.end_session(pid, metrics_flags)&#10;  ```&#10;&#10;### Efficient Metric Collection&#10;&#10;Combine only the metrics you need to minimize overhead:&#10;&#10;```python&#10;# Only collect CPU and memory metrics&#10;flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Error Handling&#10;&#10;Always handle potential errors:&#10;&#10;```python&#10;try:&#10;    results = metrics.get_snapshot(pid, metrics_flags)&#10;except (RuntimeError, FileNotFoundError) as e:&#10;    print(f&quot;Error collecting metrics: {e}&quot;)&#10;```&#10;&#10;### Performance Monitoring Example&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def monitor_process(pid, duration_seconds=60, interval_seconds=5):&#10;    metrics = ProcessMetrics()&#10;    flags = (ProcessMetrics.METRIC_CPU_USAGE | &#10;             ProcessMetrics.METRIC_WORKING_SET | &#10;             ProcessMetrics.METRIC_PRIVATE_BYTES)&#10;    &#10;    end_time = time.time() + duration_seconds&#10;    &#10;    while time.time() &lt; end_time:&#10;        try:&#10;            snapshot = metrics.get_snapshot(pid, flags)&#10;            print(f&quot;CPU: {snapshot['cpu_usage']['percent']}%, &quot;&#10;                  f&quot;Memory: {snapshot['memory']['working_set'] / (1024*1024):.2f} MB&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error: {e}&quot;)&#10;        &#10;        time.sleep(interval_seconds)&#10;```&#10;&#10;" />
              <option name="updatedContent" value="# Process Inspection (processInspect) Module&#10;&#10;## Module Overview&#10;&#10;The `processInspect` module provides comprehensive process and system metrics collection capabilities through the `ProcessMetrics` class. This class interfaces with a native DLL to collect detailed metrics about Windows processes with minimal performance overhead, offering insights beyond what's available through standard Python libraries.&#10;&#10;## ProcessMetrics Class&#10;&#10;### Class Description&#10;`ProcessMetrics` is a wrapper class that interfaces with the native `processInspect` DLL to collect various system and process metrics on Windows systems. It supports both instant snapshots and time-span measurements for comprehensive performance analysis.&#10;&#10;### Initialization&#10;```python&#10;metrics = ProcessMetrics()&#10;```&#10;&#10;When instantiating the class, it:&#10;- Loads the appropriate DLL using the `load_dll` helper function:&#10;  - Determines system architecture (x86/x64) automatically&#10;  - Searches for the appropriate DLL in the standard distribution paths&#10;  - Configures the loader to use `ctypes.CDLL` for this module's functions&#10;- Sets up ctypes function prototypes and return types for type safety:&#10;  - Defines appropriate argument types for all DLL functions&#10;  - Defines appropriate return types for all DLL functions&#10;&#10;### DLL Loading Details&#10;&#10;The `ProcessMetrics` class uses the centralized `load_dll` function with these parameters:&#10;- `dll_prefix_name=&quot;processInspect&quot;`: Loads either `processInspect_x64.dll` or `processInspect_x86.dll` based on architecture&#10;- `dll_load_func=ctypes.CDLL`: Uses standard CDLL loader for this module's C functions&#10;&#10;The DLL search mechanism looks in these locations by default:&#10;- `./dist/{arch}/processInspect_{arch}.dll`&#10;- `../dist/{arch}/processInspect_{arch}.dll`&#10;- `../../dist/{arch}/processInspect_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;### Constants&#10;&#10;The class provides constants for selecting which metrics to collect:&#10;&#10;| Constant | Value | Description |&#10;|----------|-------|-------------|&#10;| `METRIC_WORKING_SET` | 0x01 | Memory currently in RAM (working set) |&#10;| `METRIC_PRIVATE_BYTES` | 0x02 | Memory exclusively allocated to the process |&#10;| `METRIC_PAGEFILE` | 0x04 | Memory usage in the pagefile |&#10;| `METRIC_HANDLES` | 0x08 | Number of handles open by the process |&#10;| `METRIC_THREADS` | 0x10 | Number of threads in the process |&#10;| `METRIC_CPU_USAGE` | 0x20 | CPU usage percentage |&#10;| `METRIC_IO` | 0x40 | I/O statistics (reads, writes) |&#10;| `METRIC_NET` | 0x80 | Network statistics |&#10;&#10;These constants can be combined using bitwise OR (`|`) to select multiple metrics:&#10;&#10;```python&#10;# Select both CPU usage and working set metrics&#10;metrics_flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Methods&#10;&#10;#### `_json_call(func, pid: int, metrics: int, _buffer_size: int = 4096) -&gt; dict`&#10;&#10;Internal helper method that calls a DLL function that returns JSON data in a buffer, parses it, and returns it as a Python dictionary.&#10;&#10;**Parameters:**&#10;- `func` (callable): DLL function to call, which fills a buffer with JSON&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics flags to request&#10;- `_buffer_size` (int): Size of the buffer to hold JSON data (default 4096 bytes)&#10;&#10;**Returns:**&#10;- `dict`: Parsed JSON metrics&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the DLL function call returns failure&#10;&#10;**Implementation Details:**&#10;- Creates a string buffer of specified size (4KB default)&#10;- Calls the provided DLL function with pid, metrics flags, buffer pointer, and buffer size&#10;- Checks for successful return value&#10;- Decodes the buffer content from UTF-8 to a string&#10;- Parses the JSON string into a Python dictionary&#10;- Returns the parsed dictionary or raises an exception on failure&#10;&#10;#### `start_session(pid: int, metrics: int) -&gt; bool`&#10;&#10;Starts a metrics collection session for a specific process.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to monitor&#10;- `metrics` (int): Bitmask of metrics to collect, using class constants&#10;&#10;**Returns:**&#10;- `bool`: `True` if session started successfully, `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Directly calls the native DLL's `start_metrics_collection` function&#10;- Returns a boolean indicating success or failure&#10;- Does not raise exceptions for failure, allowing for graceful handling by caller&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;success = pm.start_session(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;)&#10;```&#10;&#10;#### `end_session(pid: int, metrics: int) -&gt; dict`&#10;&#10;Ends a previously started metrics collection session and retrieves results.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID of the session to end&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Metrics collected during the session, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Implementation Details:**&#10;- Uses the internal `_json_call` helper to call the `end_metrics_collection` DLL function&#10;- Provides a detailed exception if the operation fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;# Start session first&#10;pm.start_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;# ... do some work ...&#10;# End session and get results&#10;results = pm.end_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;```&#10;&#10;#### `get_snapshot(pid: int, metrics: int) -&gt; dict`&#10;&#10;Retrieves an instant snapshot of metrics for a process without starting a session.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Current metrics snapshot, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Implementation Details:**&#10;- Uses the internal `_json_call` helper to call the `get_metrics_json` DLL function&#10;- Provides a detailed exception if the operation fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;snapshot = pm.get_snapshot(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | &#10;    ProcessMetrics.METRIC_WORKING_SET | &#10;    ProcessMetrics.METRIC_HANDLES&#10;)&#10;```&#10;&#10;### Return Value Structure&#10;&#10;All methods that return metrics provide a dictionary with the following structure (keys present depend on requested metrics):&#10;&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,                    // Process ID&#10;  &quot;name&quot;: &quot;example.exe&quot;,          // Process name&#10;  &quot;timestamp&quot;: 1629384756,        // Unix timestamp&#10;  &quot;duration&quot;: 5.23,               // Duration in seconds (for session metrics)&#10;  &quot;cpu_usage&quot;: {                  // If METRIC_CPU_USAGE requested&#10;    &quot;percent&quot;: 14.5,              // CPU usage percentage&#10;    &quot;kernel_time&quot;: 0.234,         // Time spent in kernel mode (seconds)&#10;    &quot;user_time&quot;: 1.456            // Time spent in user mode (seconds)&#10;  },&#10;  &quot;memory&quot;: {                     // Memory metrics&#10;    &quot;working_set&quot;: 123456789,     // If METRIC_WORKING_SET requested (bytes)&#10;    &quot;private_bytes&quot;: 98765432,    // If METRIC_PRIVATE_BYTES requested (bytes)&#10;    &quot;pagefile&quot;: 45678912          // If METRIC_PAGEFILE requested (bytes)&#10;  },&#10;  &quot;handles&quot;: 345,                 // If METRIC_HANDLES requested&#10;  &quot;threads&quot;: 12,                  // If METRIC_THREADS requested&#10;  &quot;io&quot;: {                         // If METRIC_IO requested&#10;    &quot;reads&quot;: 1234,                // Number of read operations&#10;    &quot;writes&quot;: 5678,               // Number of write operations&#10;    &quot;bytes_read&quot;: 12345678,       // Total bytes read&#10;    &quot;bytes_written&quot;: 87654321     // Total bytes written&#10;  },&#10;  &quot;network&quot;: {                    // If METRIC_NET requested&#10;    &quot;bytes_sent&quot;: 123456,         // Total bytes sent&#10;    &quot;bytes_received&quot;: 654321      // Total bytes received&#10;  }&#10;}&#10;```&#10;&#10;### Error Handling&#10;&#10;The class implements robust error handling:&#10;&#10;- **Buffer Allocation**: Creates appropriately sized buffers for JSON responses&#10;- **Return Value Checking**: Verifies all DLL function calls succeed&#10;- **Exception Handling**: Raises descriptive RuntimeError with process ID on failure&#10;- **JSON Parsing**: Safely decodes and parses JSON data from the native DLL&#10;&#10;## Usage Best Practices&#10;&#10;### Selecting the Right Method&#10;&#10;- **For a single point-in-time measurement:**&#10;  ```python&#10;  snapshot = metrics.get_snapshot(pid, metrics_flags)&#10;  ```&#10;&#10;- **For measuring performance over time:**&#10;  ```python&#10;  metrics.start_session(pid, metrics_flags)&#10;  # ... time passes ...&#10;  results = metrics.end_session(pid, metrics_flags)&#10;  ```&#10;&#10;### Efficient Metric Collection&#10;&#10;Combine only the metrics you need to minimize overhead:&#10;&#10;```python&#10;# Only collect CPU and memory metrics&#10;flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Error Handling&#10;&#10;Always handle potential errors:&#10;&#10;```python&#10;try:&#10;    results = metrics.get_snapshot(pid, metrics_flags)&#10;except (RuntimeError, FileNotFoundError) as e:&#10;    print(f&quot;Error collecting metrics: {e}&quot;)&#10;```&#10;&#10;### Reuse ProcessMetrics Instance&#10;&#10;For efficiency, create a single instance and reuse it:&#10;&#10;```python&#10;# Create once&#10;metrics = ProcessMetrics()&#10;&#10;# Use for multiple operations&#10;metrics.start_session(pid1, flags)&#10;snapshot = metrics.get_snapshot(pid2, flags)&#10;results = metrics.end_session(pid1, flags)&#10;```&#10;&#10;### Performance Monitoring Example&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def monitor_process(pid, duration_seconds=60, interval_seconds=5):&#10;    metrics = ProcessMetrics()&#10;    flags = (ProcessMetrics.METRIC_CPU_USAGE | &#10;             ProcessMetrics.METRIC_WORKING_SET | &#10;             ProcessMetrics.METRIC_PRIVATE_BYTES)&#10;    &#10;    end_time = time.time() + duration_seconds&#10;    &#10;    while time.time() &lt; end_time:&#10;        try:&#10;            snapshot = metrics.get_snapshot(pid, flags)&#10;            print(f&quot;CPU: {snapshot['cpu_usage']['percent']}%, &quot;&#10;                  f&quot;Memory: {snapshot['memory']['working_set'] / (1024*1024):.2f} MB&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error: {e}&quot;)&#10;        &#10;        time.sleep(interval_seconds)&#10;```&#10;&#10;### Working with Multiple Processes&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def compare_processes(pids, metrics_flags):&#10;    pm = ProcessMetrics()&#10;    results = {}&#10;    &#10;    # Start sessions for all processes&#10;    for pid in pids:&#10;        pm.start_session(pid, metrics_flags)&#10;    &#10;    # Wait for some time&#10;    time.sleep(30)&#10;    &#10;    # End sessions and collect results&#10;    for pid in pids:&#10;        try:&#10;            results[pid] = pm.end_session(pid, metrics_flags)&#10;        except RuntimeError as e:&#10;            results[pid] = f&quot;Error: {e}&quot;&#10;    &#10;    return results&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.h" />
              <option name="updatedContent" value="#ifndef PYCTOOLS_HRNG_H&#10;#define PYCTOOLS_HRNG_H&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/**&#10; * Checks if the CPU supports the RDRAND instruction&#10; * &#10; * @return 1 if supported, 0 if not&#10; */&#10;int has_rdrand(void);&#10;&#10;/**&#10; * Fills a buffer with random bytes using hardware RNG (RDRAND if available)&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int read_hwrng(unsigned char* buffer, int size);&#10;&#10;/**&#10; * Maximum security RNG that uses multiple entropy sources:&#10; * - Hardware RNG (RDRAND)&#10; * - CPU information and timings&#10; * - Audio input (microphone)&#10; * - Battery/power status&#10; * - Memory and process statistics&#10; * - Network statistics&#10; * - Performance counters&#10; * &#10; * The entropy is mixed using cryptographic algorithms.&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int MaxRNG(unsigned char* buffer, int size);&#10;&#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif // PYCTOOLS_HRNG_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.md" />
              <option name="originalContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;The `/dev/urandom/` of Windows.&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hRng.c&lt;/summary&gt;&#10;&#10;## hRng.c&#10;&#10;Implements a hardware random number generator using the RDRAND instruction (if supported by the CPU).&#10;&#10;### Key Function&#10;- `int read_hwrng(unsigned char* buffer, int size)`&#10;    - Fills `buffer` with `size` random bytes from the hardware RNG.&#10;    - Returns 1 on success, 0 if RDRAND is not supported or fails.&#10;    - Exported for use by Python via ctypes.&#10;&#10;### Notes&#10;- Checks for RDRAND support using CPUID.&#10;- Used by `pyCTools.hwrng`.&#10;&lt;/details&gt;&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage, disk I/O)&#10;  - Audio data from microphone&#10;  - Battery and power status information&#10;  - Network statistics&#10;- Secure entropy mixing using SHA-256&#10;- Thread-safe operation&#10;- Self-testing capabilities&#10;- Fallback mechanisms when primary sources fail&#10;- Multiple security levels with extended entropy gathering&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int has_rdrand()`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int read_hwrng(unsigned char* buffer, const int size)`&#10;Fills a buffer with random data using hardware RNG (RDRAND) with retry logic.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG_ThreadSafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for MaxRNG.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int MaxRNG_Extended(unsigned char* buffer, const int size, const int intensive_level)`&#10;Enhanced random number generation with configurable intensity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `intensive_level`: Level of entropy gathering intensity (1-5):&#10;  - `1`: Standard MaxRNG operation&#10;  - `2`: Additional CPU jitter entropy&#10;  - `3+`: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int RNG_SelfTest(void)`&#10;Self-diagnostic function to verify RNG functionality.&#10;&#10;**Returns:**&#10;- `1` if all tests pass&#10;- `0` if any test fails&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RNG_SelfTest_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func MaxRNG = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;MaxRNG&quot;);&#10;    RNG_SelfTest_Func RNG_SelfTest = (RNG_SelfTest_Func)GetProcAddress(hRngDll, &quot;RNG_SelfTest&quot;);&#10;    &#10;    if (!MaxRNG || !RNG_SelfTest) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Run self-test&#10;    if (!RNG_SelfTest()) {&#10;        printf(&quot;RNG self-test failed\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (MaxRNG(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_ThreadSafe_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = (MaxRNG_ThreadSafe_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = MaxRNG_ThreadSafe(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = &#10;        (MaxRNG_ThreadSafe_Func)GetProcAddress(hRngDll, &quot;MaxRNG_ThreadSafe&quot;);&#10;    &#10;    if (!MaxRNG_ThreadSafe) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)MaxRNG_ThreadSafe, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using MaxRNG_Extended for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Extended_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Extended_Func MaxRNG_Extended = &#10;        (MaxRNG_Extended_Func)GetProcAddress(hRngDll, &quot;MaxRNG_Extended&quot;);&#10;    &#10;    if (!MaxRNG_Extended) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (intensity level 5)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (MaxRNG_Extended(buffer, sizeof(buffer), 5)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information&#10;   - CPU timing information&#10;   - Disk I/O statistics&#10;   - High-precision performance counters&#10;&#10;4. **Audio Data**&#10;   - Samples microphone input&#10;   - Falls back to timing data if no microphone is available&#10;&#10;5. **Battery/Power Information**&#10;   - Battery state and charge levels&#10;   - Power status information&#10;&#10;6. **Network Statistics**&#10;   - TCP/IP statistics&#10;   - Network adapter information&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API to ensure:&#10;&#10;- Uniform distribution of random bits&#10;- High entropy density&#10;- Protection against predictability attacks&#10;&#10;### Security Considerations&#10;&#10;- The library securely zeroes memory containing sensitive data using SecureZeroMemory&#10;- Multiple fallback mechanisms ensure reliability when primary entropy sources fail&#10;- Thread synchronization protects against race conditions in multi-threaded environments&#10;- Self-test functionality verifies proper operation before use&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - winmm.lib&#10;  - bcrypt.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;  - powrprof.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to include the appropriate header file and link against the hRng.dll library.&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;hRng.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;The `/dev/urandom/` of Windows.&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hRng.c&lt;/summary&gt;&#10;&#10;## hRng.c&#10;&#10;Implements a hardware random number generator using the RDRAND instruction (if supported by the CPU).&#10;&#10;### Key Function&#10;- `int read_hwrng(unsigned char* buffer, int size)`&#10;    - Fills `buffer` with `size` random bytes from the hardware RNG.&#10;    - Returns 1 on success, 0 if RDRAND is not supported or fails.&#10;    - Exported for use by Python via ctypes.&#10;&#10;### Notes&#10;- Checks for RDRAND support using CPUID.&#10;- Used by `pyCTools.hwrng`.&#10;&lt;/details&gt;&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage)&#10;  - Process memory information&#10;  - Disk space statistics&#10;  - Network adapter and TCP statistics&#10;  - Battery and power status information&#10;- Secure entropy mixing using SHA-256 via Windows BCrypt API&#10;- Thread-safe operation with proper synchronization&#10;- Configurable complexity levels for enhanced security&#10;- Fallback mechanisms when hardware RNG is unavailable&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int test_rng_available(void)`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int test_threading_available(void)`&#10;Checks if threading primitives are initialized.&#10;&#10;**Returns:**&#10;- `1` if threading primitives are initialized&#10;- `0` otherwise&#10;&#10;#### `int maxrng(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources with basic complexity.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `void maxrng_init(void)`&#10;Initializes threading primitives for thread-safe operation.&#10;&#10;**Returns:**&#10;- None&#10;&#10;#### `int maxrng_threadsafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for the RNG function.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int maxrng_ultra(unsigned char* buffer, const int size, int complexity)`&#10;Enhanced random number generation with configurable complexity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `complexity`: Level of entropy gathering intensity (1-10):&#10;  - Higher values increase the number of entropy gathering rounds&#10;  - Values are automatically clamped between 1 and 10&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RngAvailable_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func rng = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;maxrng&quot;);&#10;    RngAvailable_Func rngAvailable = (RngAvailable_Func)GetProcAddress(hRngDll, &quot;test_rng_available&quot;);&#10;    &#10;    if (!rng || !rngAvailable) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Check if hardware RNG is available&#10;    printf(&quot;Hardware RNG available: %s\n&quot;, rngAvailable() ? &quot;Yes&quot; : &quot;No&quot;);&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (rng(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef void (*Init_Func)(void);&#10;typedef int (*ThreadSafe_RNG_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    ThreadSafe_RNG_Func rng = (ThreadSafe_RNG_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = rng(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    Init_Func init = (Init_Func)GetProcAddress(hRngDll, &quot;maxrng_init&quot;);&#10;    ThreadSafe_RNG_Func threadSafeRng = &#10;        (ThreadSafe_RNG_Func)GetProcAddress(hRngDll, &quot;maxrng_threadsafe&quot;);&#10;    &#10;    if (!init || !threadSafeRng) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Initialize threading primitives&#10;    init();&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)threadSafeRng, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using Ultra Mode for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Ultra_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Ultra_Func ultraRng = &#10;        (MaxRNG_Ultra_Func)GetProcAddress(hRngDll, &quot;maxrng_ultra&quot;);&#10;    &#10;    if (!ultraRng) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (complexity level 10)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (ultraRng(buffer, sizeof(buffer), 10)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability (up to 10 retries)&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information via GetProcessMemoryInfo&#10;   - High-precision performance counters via QueryPerformanceCounter&#10;&#10;4. **Storage Information**&#10;   - Disk free space statistics via GetDiskFreeSpaceEx&#10;&#10;5. **Audio Timing**&#10;   - Timing-based entropy collection with sleep intervals&#10;   - Used as a fallback entropy source&#10;&#10;6. **Battery/Power Information**&#10;   - System power status via GetSystemPowerStatus&#10;&#10;7. **Network Statistics**&#10;   - TCP statistics via GetTcpStatistics&#10;   - Network adapter information via GetAdaptersInfo&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API:&#10;&#10;- Multiple rounds of hashing based on the complexity parameter&#10;- Secure handling of hash state between rounds&#10;- Proper cleanup of cryptographic resources&#10;&#10;### Thread Safety&#10;&#10;- Uses Windows critical sections for thread synchronization&#10;- Initialization of threading primitives via maxrng_init()&#10;- Thread-safe API via maxrng_threadsafe()&#10;&#10;### Security Considerations&#10;&#10;- Multiple fallback mechanisms ensure reliability when hardware RNG is unavailable&#10;- Complexity parameter allows for trading off performance vs. security&#10;- Clean error handling with proper resource cleanup&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - bcrypt.lib&#10;  - winmm.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to link against the required libraries:&#10;&#10;```c&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/processInspect.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/processInspect.md" />
              <option name="updatedContent" value="# Process Inspection Module (processInspect)&#10;&#10;## Overview&#10;&#10;The Process Inspection Module provides powerful, low-level access to Windows process metrics and performance data. This library allows applications to monitor process resource usage with minimal overhead, supporting both instantaneous measurements and differential metrics over specified time periods.&#10;&#10;## Key Features&#10;&#10;- Low-overhead process monitoring&#10;- Memory usage metrics (working set, private bytes, pagefile usage)&#10;- Process resource tracking (handles, threads)&#10;- CPU utilization measurement&#10;- I/O operations monitoring (read/write)&#10;- Support for both snapshot and time-interval measurements&#10;- JSON-formatted output for easy integration&#10;- Customizable metrics selection&#10;&#10;## API Reference&#10;&#10;### Constants&#10;&#10;#### Metrics Flags&#10;&#10;The following constants are used to specify which metrics to collect:&#10;&#10;```c&#10;#define METRIC_WORKING_SET   0x01  // Process working set size&#10;#define METRIC_PRIVATE_BYTES 0x02  // Private memory usage&#10;#define METRIC_PAGEFILE      0x04  // Pagefile usage&#10;#define METRIC_HANDLES       0x08  // Handle count&#10;#define METRIC_THREADS       0x10  // Thread count&#10;#define METRIC_CPU_USAGE     0x20  // CPU usage percentage&#10;#define METRIC_IO            0x40  // I/O read/write operations&#10;#define METRIC_NET           0x80  // Network usage (when implemented)&#10;```&#10;&#10;### Functions&#10;&#10;#### `int get_metrics_json(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Takes an instantaneous snapshot of the specified process metrics.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, insufficient permissions, buffer too small)&#10;&#10;**JSON Output Format:**&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,&#10;  &quot;working_set_kb&quot;: 45678,&#10;  &quot;private_kb&quot;: 34567,&#10;  &quot;pagefile_kb&quot;: 23456,&#10;  &quot;handles&quot;: 345,&#10;  &quot;threads&quot;: 12,&#10;  &quot;cpu&quot;: 3.45,&#10;  &quot;io_read_kb&quot;: 1234,&#10;  &quot;io_write_kb&quot;: 5678&#10;}&#10;```&#10;&#10;#### `int start_metrics_collection(DWORD pid, DWORD metrics)`&#10;&#10;Begins collecting metrics for a process over a time period. Must be paired with a later call to `end_metrics_collection()`.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;&#10;**Returns:**&#10;- `1` if collection successfully started&#10;- `0` on failure (invalid process, insufficient permissions)&#10;&#10;#### `int end_metrics_collection(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Ends metrics collection and calculates differentials for the time period since `start_metrics_collection()` was called.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID (must match the one used in `start_metrics_collection()`)&#10;- `metrics`: Bitwise combination of METRIC_* flags (must match the ones used in `start_metrics_collection()`)&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, metrics mismatch, insufficient permissions, buffer too small)&#10;&#10;**Notes:**&#10;- CPU and I/O metrics are reported as deltas between start and end collection&#10;- Memory metrics are instantaneous values at the time of call&#10;&#10;## Usage Examples&#10;&#10;### Taking a Snapshot of Process Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!GetMetricsJson) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                         METRIC_HANDLES | METRIC_CPU_USAGE;&#10;    &#10;    char json_buffer[1024] = {0};&#10;    &#10;    if (GetMetricsJson(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Process metrics: %s\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get process metrics\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Measuring Process Metrics Over Time&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    if (StartMetricsCollection(pid, metrics)) {&#10;        printf(&quot;Started metrics collection. Monitoring for 5 seconds...\n&quot;);&#10;        &#10;        // Wait for a period to collect metrics&#10;        Sleep(5000);&#10;        &#10;        char json_buffer[1024] = {0};&#10;        if (EndMetricsCollection(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Process metrics over 5 seconds: %s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Complete Example with All Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;// Metrics flags&#10;#define METRIC_WORKING_SET   0x01&#10;#define METRIC_PRIVATE_BYTES 0x02&#10;#define METRIC_PAGEFILE      0x04&#10;#define METRIC_HANDLES       0x08&#10;#define METRIC_THREADS       0x10&#10;#define METRIC_CPU_USAGE     0x20&#10;#define METRIC_IO            0x40&#10;#define METRIC_NET           0x80&#10;&#10;int main(int argc, char* argv[]) {&#10;    if (argc &lt; 2) {&#10;        printf(&quot;Usage: %s &lt;PID&gt;\n&quot;, argv[0]);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = (DWORD)atoi(argv[1]);&#10;    &#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection || !GetMetricsJson) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // All available metrics&#10;    const DWORD all_metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                             METRIC_PAGEFILE | METRIC_HANDLES | METRIC_THREADS | &#10;                             METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    // First, take an instant snapshot&#10;    char json_buffer[1024] = {0};&#10;    if (GetMetricsJson(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Instant metrics snapshot:\n%s\n\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get instant metrics\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // Then measure over time&#10;    if (StartMetricsCollection(pid, all_metrics)) {&#10;        printf(&quot;Collecting metrics for 10 seconds...\n&quot;);&#10;        Sleep(10000);&#10;        &#10;        if (EndMetricsCollection(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Metrics over 10 seconds:\n%s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Process Metrics Explained&#10;&#10;#### Memory Metrics&#10;&#10;- **Working Set (METRIC_WORKING_SET)**: &#10;  The set of memory pages currently visible to the process in physical RAM. This includes shared and private pages.&#10;&#10;- **Private Bytes (METRIC_PRIVATE_BYTES)**:&#10;  Memory that cannot be shared with other processes. This represents the actual memory cost of the process.&#10;&#10;- **Pagefile Usage (METRIC_PAGEFILE)**:&#10;  The amount of the system page file that is being used by the process. This includes all memory that the process has touched, including pages that are in RAM.&#10;&#10;#### Resource Metrics&#10;&#10;- **Handles (METRIC_HANDLES)**:&#10;  The number of object handles in the process's handle table. This includes files, registry keys, events, etc.&#10;&#10;- **Threads (METRIC_THREADS)**:&#10;  The number of threads currently executing in the process.&#10;&#10;#### Performance Metrics&#10;&#10;- **CPU Usage (METRIC_CPU_USAGE)**:&#10;  Percentage of available CPU time that the process has used. When collected over time, this represents the average usage during that period.&#10;&#10;- **I/O Operations (METRIC_IO)**:&#10;  Total bytes read from and written to the disk by the process. When collected over time, this represents the bytes transferred during that period.&#10;&#10;### Implementation Details&#10;&#10;- The library uses Windows Performance Data Helper (PDH) and Process Status API (PSAPI) to collect metrics&#10;- Thread synchronization is implemented for metric collection over time&#10;- The implementation uses Windows-specific APIs and is optimized for minimal overhead&#10;- CPU usage calculation takes into account all cores/processors in the system&#10;- All memory metrics are reported in kilobytes (KB)&#10;&#10;### Known Limitations&#10;&#10;- Requires administrator privileges to monitor some processes&#10;- CPU usage metrics may not be 100% accurate for very short-lived processes&#10;- Network metrics are reserved for future implementation (METRIC_NET flag)&#10;- Only supports Windows operating systems&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - psapi.lib&#10;  - iphlpapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;processInspect.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;if (hModule) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;&#10;### Python Integration&#10;&#10;The library can be easily used from Python via ctypes:&#10;&#10;```python&#10;import ctypes&#10;from ctypes import c_int, c_ulong, c_char_p, c_size_t&#10;&#10;# Load the DLL&#10;process_inspect = ctypes.CDLL(&quot;processInspect.dll&quot;)&#10;&#10;# Define metrics constants&#10;METRIC_WORKING_SET = 0x01&#10;METRIC_PRIVATE_BYTES = 0x02&#10;METRIC_PAGEFILE = 0x04&#10;METRIC_HANDLES = 0x08&#10;METRIC_THREADS = 0x10&#10;METRIC_CPU_USAGE = 0x20&#10;METRIC_IO = 0x40&#10;METRIC_ALL = 0x7F&#10;&#10;# Define function prototypes&#10;get_metrics_json = process_inspect.get_metrics_json&#10;get_metrics_json.argtypes = [c_ulong, c_ulong, c_char_p, c_size_t]&#10;get_metrics_json.restype = c_int&#10;&#10;# Usage example&#10;def get_process_metrics(pid, metrics=METRIC_ALL):&#10;    buffer = ctypes.create_string_buffer(1024)&#10;    if get_metrics_json(pid, metrics, buffer, len(buffer)):&#10;        return buffer.value.decode('utf-8')&#10;    return None&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import json&#10;    &#10;    pid = 1234  # Replace with actual PID&#10;    metrics_json = get_process_metrics(pid)&#10;    if metrics_json:&#10;        metrics = json.loads(metrics_json)&#10;        print(f&quot;Process {pid} is using {metrics.get('working_set_kb', 0):,} KB of memory&quot;)&#10;        print(f&quot;CPU Usage: {metrics.get('cpu', 0):.2f}%&quot;)&#10;```&#10;&#10;## License and Attribution&#10;&#10;This Process Inspection Module is provided for monitoring and analyzing process performance in Windows environments.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_hrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_hrng.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
              <option name="updatedContent" value="oimport ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tool/dist.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tool/dist.md" />
              <option name="originalContent" value="# PowerShell Script Documentation: `bin` Folder Validation and ZIP Packaging&#10;&#10;---&#10;&#10;## Overview&#10;&#10;This PowerShell script performs the following tasks:&#10;&#10;1. Validates the folder structure and file consistency inside a `bin` directory.&#10;2. Ensures the presence of matching file types and names between `x64` and `x86` subfolders.&#10;3. Verifies DLL naming conventions.&#10;4. Compresses the validated `bin` folder into a ZIP archive in the `dist/rawBinaryZipped` directory.&#10;5. Creates a SHA256 checksum file for the ZIP archive.&#10;&#10;---&#10;&#10;## Prerequisites&#10;&#10;* PowerShell 5.1 or higher (for `Compress-Archive` and `Get-FileHash` cmdlets).&#10;* The script should be run from a directory such that `../pyCTools/bin` refers to your binary folder, or you can input a custom path when prompted.&#10;* The script expects that `compilerHelper.ps1` has been executed previously to create the bin directory.&#10;* Write permission to create a `dist/rawBinaryZipped` folder and to write files inside it.&#10;&#10;---&#10;&#10;## Script Breakdown&#10;&#10;### Global Variables&#10;&#10;* `$debug` (Boolean):&#10;  Controls verbose error output. When `$true`, detailed error messages are shown.&#10;&#10;### Function: `Write-CustomError`&#10;&#10;A helper function to display errors consistently in red.&#10;Parameters:&#10;&#10;* `$Message` (string): Main error message to display.&#10;* `$Details` (string, optional): Additional debug info displayed only if `$debug` is `$true`.&#10;&#10;---&#10;&#10;### Main Script Logic (Inside `try` block)&#10;&#10;#### 1. Change Directory&#10;&#10;* `Set-Location ..`&#10;  Moves the current working directory one level up. The script expects the `dist` folder at this level.&#10;&#10;#### 2. Locate `dist` Folder&#10;&#10;* Attempts to find a `dist` folder at the current location.&#10;* If not found, prompts the user to enter a full path to the `dist` folder.&#10;* Exits with error if the path is invalid or missing.&#10;&#10;#### 3. Validate Subfolders&#10;&#10;* Checks for two mandatory subdirectories inside `dist`:&#10;&#10;    * `x64`&#10;    * `x86`&#10;* If either is missing, the script exits with an error.&#10;&#10;#### 4. File Type and Count Validation&#10;&#10;* Considers the file extensions: `dll`, `exp`, `lib`, and `obj`.&#10;* Retrieves filenames (just names, no paths) for each extension from both `x64` and `x86`.&#10;* Checks if both subfolders have the **same number** of files for each extension.&#10;* If counts differ, it outputs an error showing counts for each folder.&#10;&#10;#### 5. File Name Matching&#10;&#10;* Extracts the base filename (without extension) for each file.&#10;* For DLL files, removes platform suffixes `_x64` or `_x86` for fair comparison.&#10;* Sorts both sets of base names.&#10;* Checks if the sorted lists match exactly.&#10;* If mismatched, outputs the differing filenames for both folders.&#10;&#10;#### 6. DLL Naming Convention Check&#10;&#10;* For each DLL file in both folders, checks if the filename contains the folder name (`x64` or `x86`) in any case.&#10;* If a DLL file does **not** contain the folder name, the script throws an error.&#10;&#10;#### 7. Success Message&#10;&#10;* If all validations pass, it outputs:&#10;  `&quot;dist folder validated successfully.&quot;`&#10;&#10;---&#10;&#10;### ZIP Compression&#10;&#10;* Defines a `bin` folder alongside `dist` to store output archives.&#10;* Creates `bin` if it doesn't exist.&#10;* Compresses the entire contents of `dist` into `bin\dist.zip` using `Compress-Archive`.&#10;* Overwrites existing ZIP if present.&#10;* Outputs success or failure message accordingly.&#10;&#10;---&#10;&#10;### SHA256 Checksum File Creation&#10;&#10;* Defines function `SHA256File` which:&#10;&#10;    * Computes SHA256 hash of the given file.&#10;    * Creates a `.sha256` file next to the archive.&#10;    * File format:&#10;&#10;      ```&#10;      Algorithm : SHA256&#10;      Hash      : &lt;computed_hash&gt;&#10;      ```&#10;&#10;* Generates SHA256 checksum for `dist.zip` only.&#10;&#10;* Outputs confirmation on success or error message on failure.&#10;&#10;---&#10;&#10;### Error Handling&#10;&#10;* Any uncaught exceptions during the script execution are caught.&#10;* Displays a consistent error message using `Write-CustomError`.&#10;* Terminates the script with exit code `1`.&#10;&#10;---&#10;&#10;## How to Use&#10;&#10;1. Place this script somewhere inside your project directory.&#10;&#10;2. Ensure your project has a `dist` folder structured as follows:&#10;&#10;   ```&#10;   dist/&#10;      x64/&#10;          *.dll, *.exp, *.lib, *.obj files&#10;      x86/&#10;           *.dll, *.exp, *.lib, *.obj files&#10;   ```&#10;&#10;3. The DLL filenames must include `_x64` or `_x86` suffix corresponding to their folder.&#10;&#10;4. Run the script from a directory such that moving one directory up (`..`) leads to the location containing the `dist` folder.&#10;&#10;5. If no `dist` folder is found, the script will ask you to enter its full path.&#10;&#10;6. The script will validate folder structure, file counts, and naming conventions.&#10;&#10;7. On successful validation, it will compress `dist` into `bin\dist.zip` and generate a SHA256 checksum file.&#10;&#10;---&#10;&#10;## Example Output&#10;&#10;```&#10;dist folder validated successfully.&#10;Created bin folder at C:\Path\To\bin&#10;ZIP archive created at C:\Path\To\bin\dist.zip&#10;SHA256 file created: C:\Path\To\bin\dist.zip.sha256&#10;All done.&#10;```&#10;&#10;---&#10;&#10;## Notes&#10;&#10;* The script currently does **not** support or require external compression tools like WinRAR or RAR.&#10;* ZIP compression is handled entirely via PowerShell's native `Compress-Archive`.&#10;* The SHA256 format was chosen to be human-readable and simple.&#10;* You can toggle `$debug = $true` at the top to get more detailed error information during development or troubleshooting.&#10;&#10;---" />
              <option name="updatedContent" value="# PowerShell Script Documentation: `bin` Folder Validation and ZIP Packaging&#10;&#10;---&#10;&#10;## Overview&#10;&#10;This PowerShell script performs the following tasks:&#10;&#10;1. Validates the folder structure and file consistency inside a `bin` directory.&#10;2. Ensures the presence of matching file types and names between `x64` and `x86` subfolders.&#10;3. Verifies DLL naming conventions.&#10;4. Compresses the validated `bin` folder into a ZIP archive in the `dist/rawBinaryZipped` directory.&#10;5. Creates a SHA256 checksum file for the ZIP archive.&#10;&#10;---&#10;&#10;## Prerequisites&#10;&#10;* PowerShell 5.1 or higher (for `Compress-Archive` and `Get-FileHash` cmdlets).&#10;* The script should be run from a directory such that `../pyCTools/bin` refers to your binary folder, or you can input a custom path when prompted.&#10;* The script expects that `compilerHelper.ps1` has been executed previously to create the bin directory.&#10;* Write permission to create a `dist/rawBinaryZipped` folder and to write files inside it.&#10;&#10;---&#10;&#10;## Script Breakdown&#10;&#10;### Global Variables&#10;&#10;* `$debug` (Boolean):&#10;  Controls verbose error output. When `$true`, detailed error messages are shown.&#10;&#10;### Function: `Write-CustomError`&#10;&#10;A helper function to display errors consistently in red.&#10;Parameters:&#10;&#10;* `$Message` (string): Main error message to display.&#10;* `$Details` (string, optional): Additional debug info displayed only if `$debug` is `$true`.&#10;&#10;---&#10;&#10;### Main Script Logic (Inside `try` block)&#10;&#10;#### 1. Change Directory&#10;&#10;* `Set-Location ..`&#10;  Moves the current working directory one level up.&#10;&#10;#### 2. Locate `bin` Folder&#10;&#10;* Attempts to find a `bin` folder within the `pyCTools` directory.&#10;* If not found, prompts the user to enter a full path to the `bin` folder, asking if they have executed `compilerHelper.ps1`.&#10;* Exits with error if the path is invalid or missing.&#10;&#10;#### 3. Validate Subfolders&#10;&#10;* Checks for two mandatory subdirectories inside `bin`:&#10;&#10;    * `x64`&#10;    * `x86`&#10;* If either is missing, the script exits with an error.&#10;&#10;#### 4. File Type and Count Validation&#10;&#10;* Considers the file extensions: `dll`, `exp`, `lib`, and `obj`.&#10;* Retrieves filenames (just names, no paths) for each extension from both `x64` and `x86`.&#10;* Checks if both subfolders have the **same number** of files for each extension.&#10;* If counts differ, it outputs an error showing counts for each folder.&#10;&#10;#### 5. File Name Matching&#10;&#10;* Extracts the base filename (without extension) for each file.&#10;* For DLL files, removes platform suffixes `_x64` or `_x86` for fair comparison.&#10;* Sorts both sets of base names.&#10;* Checks if the sorted lists match exactly.&#10;* If mismatched, outputs the differing filenames for both folders.&#10;&#10;#### 6. DLL Naming Convention Check&#10;&#10;* For each DLL file in both folders, checks if the filename contains the folder name (`x64` or `x86`) in any case.&#10;* If a DLL file does **not** contain the folder name, the script throws an error.&#10;&#10;#### 7. Success Message&#10;&#10;* If all validations pass, it outputs:&#10;  `&quot;bin folder validated successfully.&quot;`&#10;&#10;---&#10;&#10;### Create Output Directory&#10;&#10;* Creates a `dist/rawBinaryZipped` directory to store the output files if it doesn't already exist.&#10;* Outputs a message confirming the directory was created or noting that it already exists.&#10;&#10;---&#10;&#10;### ZIP Compression&#10;&#10;* Defines a path for the ZIP file at `dist/rawBinaryZipped/bin.zip`.&#10;* Removes any existing ZIP file with the same name.&#10;* Compresses the entire contents of `bin` into `dist/rawBinaryZipped/bin.zip` using `Compress-Archive`.&#10;* Outputs success or failure message accordingly.&#10;&#10;---&#10;&#10;### SHA256 Checksum File Creation&#10;&#10;* Defines function `SHA256File` which:&#10;&#10;    * Computes SHA256 hash of the given file.&#10;    * Creates a `.sha256` file next to the archive.&#10;    * File format:&#10;&#10;      ```&#10;      Algorithm : SHA256&#10;      Hash      : &lt;computed_hash&gt;&#10;      ```&#10;&#10;* Generates SHA256 checksum for `bin.zip`.&#10;&#10;* Outputs confirmation on success or error message on failure.&#10;&#10;---&#10;&#10;### Error Handling&#10;&#10;* Any uncaught exceptions during the script execution are caught.&#10;* Displays a consistent error message using `Write-CustomError`.&#10;* Terminates the script with exit code `1`.&#10;&#10;---&#10;&#10;## How to Use&#10;&#10;1. Place this script somewhere inside your project directory.&#10;&#10;2. Ensure you've run `compilerHelper.ps1` to create the `bin` folder structured as follows:&#10;&#10;   ```&#10;   bin/&#10;      x64/&#10;          *.dll, *.exp, *.lib, *.obj files&#10;      x86/&#10;           *.dll, *.exp, *.lib, *.obj files&#10;   ```&#10;&#10;3. The DLL filenames must include `_x64` or `_x86` suffix corresponding to their folder.&#10;&#10;4. Run the script from a directory such that moving one directory up (`..`) leads to the location containing the `pyCTools/bin` folder.&#10;&#10;5. If no `bin` folder is found, the script will ask you to enter its full path.&#10;&#10;6. The script will validate folder structure, file counts, and naming conventions.&#10;&#10;7. On successful validation, it will compress `bin` into `dist/rawBinaryZipped/bin.zip` and generate a SHA256 checksum file.&#10;&#10;---&#10;&#10;## Example Output&#10;&#10;```&#10;bin folder validated successfully.&#10;Created rawBinaryZipped folder at C:\Path\To\dist\rawBinaryZipped&#10;ZIP archive created at C:\Path\To\dist\rawBinaryZipped\bin.zip&#10;SHA256 file created: C:\Path\To\dist\rawBinaryZipped\bin.zip.sha256&#10;All done.&#10;```&#10;&#10;---&#10;&#10;## Notes&#10;&#10;* The script assumes you have already compiled your binaries using the `compilerHelper.ps1` script.&#10;* ZIP compression is handled entirely via PowerShell's native `Compress-Archive`.&#10;* The SHA256 format was chosen to be human-readable and simple.&#10;* You can toggle `$debug = $true` at the top to get more detailed error information during development or troubleshooting.&#10;&#10;---" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tool/distributionHelper.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tool/distributionHelper.ps1" />
              <option name="originalContent" value="$debug = $false&#10;&#10;function Write-CustomError {&#10;    param(&#10;        [string]$Message,&#10;        [string]$Details = &quot;&quot;&#10;    )&#10;    Write-Host $Message -ForegroundColor Red&#10;    if ($debug -and $Details) {&#10;        Write-Host $Details -ForegroundColor DarkRed&#10;    }&#10;}&#10;&#10;try {&#10;    # Move one directory up&#10;    Set-Location ..&#10;&#10;    $binPath = Join-Path (Join-Path (Get-Location) &quot;pyCTools&quot;) &quot;bin&quot;&#10;&#10;    if (-not (Test-Path $binPath -PathType Container)) {&#10;        $binPath = Read-Host &quot;bin folder not found. [Have you executed 'compilerHelper.ps1'?] =&gt; Please enter the full path to the bin folder&quot;&#10;        if (-not (Test-Path $binPath -PathType Container)) {&#10;            Write-CustomError &quot;Provided bin path does not exist or is not a directory.&quot;&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    # Validate bin structure&#10;    $x64Path = Join-Path $binPath &quot;x64&quot;&#10;    $x86Path = Join-Path $binPath &quot;x86&quot;&#10;&#10;    if (-not (Test-Path $x64Path -PathType Container)) {&#10;        Write-CustomError &quot;x64 folder is missing inside bin.&quot;&#10;        exit 1&#10;    }&#10;    if (-not (Test-Path $x86Path -PathType Container)) {&#10;        Write-CustomError &quot;x86 folder is missing inside bin.&quot;&#10;        exit 1&#10;    }&#10;&#10;    $types = @(&quot;dll&quot;, &quot;exp&quot;, &quot;lib&quot;, &quot;obj&quot;)&#10;&#10;    $x64Files = @{}&#10;    $x86Files = @{}&#10;&#10;    foreach ($ext in $types) {&#10;        $x64Files[$ext] = Get-ChildItem -Path $x64Path -Filter &quot;*.$ext&quot; -File | Select-Object -ExpandProperty Name&#10;        $x86Files[$ext] = Get-ChildItem -Path $x86Path -Filter &quot;*.$ext&quot; -File | Select-Object -ExpandProperty Name&#10;    }&#10;&#10;    foreach ($ext in $types) {&#10;        if ($x64Files[$ext].Count -ne $x86Files[$ext].Count) {&#10;            Write-CustomError &quot;Mismatch in number of *.$ext files between x64 and x86 folders.&quot;&#10;            Write-Host &quot;  - x64 count: $($x64Files[$ext].Count), x86 count: $($x86Files[$ext].Count)&quot; -ForegroundColor Red&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    foreach ($ext in $types) {&#10;        $x64BaseNames = $x64Files[$ext] | ForEach-Object { [IO.Path]::GetFileNameWithoutExtension($_) }&#10;        $x86BaseNames = $x86Files[$ext] | ForEach-Object { [IO.Path]::GetFileNameWithoutExtension($_) }&#10;&#10;        if ($ext -eq &quot;dll&quot;) {&#10;            $x64BaseNames = $x64BaseNames | ForEach-Object { $_ -replace &quot;_x64$&quot;, &quot;&quot; }&#10;            $x86BaseNames = $x86BaseNames | ForEach-Object { $_ -replace &quot;_x86$&quot;, &quot;&quot; }&#10;        }&#10;&#10;        $x64BaseNames = $x64BaseNames | Sort-Object&#10;        $x86BaseNames = $x86BaseNames | Sort-Object&#10;&#10;        if (($x64BaseNames -join ',') -ne ($x86BaseNames -join ',')) {&#10;            Write-CustomError &quot;Filenames mismatch in *.$ext files between x64 and x86 folders.&quot;&#10;            Write-Host &quot;  - x64: $($x64BaseNames -join ', ')&quot; -ForegroundColor Red&#10;            Write-Host &quot;  - x86: $($x86BaseNames -join ', ')&quot; -ForegroundColor Red&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    foreach ($folderInfo in @(@{Path=$x64Path; Name=&quot;x64&quot;}, @{Path=$x86Path; Name=&quot;x86&quot;})) {&#10;        $dllFiles = Get-ChildItem -Path $folderInfo.Path -Filter &quot;*.dll&quot; -File&#10;        foreach ($dll in $dllFiles) {&#10;            if (-not $dll.Name.ToLower().Contains($folderInfo.Name.ToLower())) {&#10;                Write-CustomError &quot;DLL file '$($dll.Name)' in folder '$($folderInfo.Name)' does NOT contain the folder name.&quot;&#10;                exit 1&#10;            }&#10;        }&#10;    }&#10;&#10;    Write-Host &quot;bin folder validated successfully.&quot;&#10;&#10;    # Create dist/rawBinaryZipped folder if not exists&#10;    $distRoot = Join-Path (Split-Path (Split-Path $binPath -Parent) -Parent) &quot;dist&quot;&#10;    $rawBinaryZippedPath = Join-Path $distRoot &quot;rawBinaryZipped&quot;&#10;&#10;    if (-not (Test-Path $rawBinaryZippedPath)) {&#10;        New-Item -Path $rawBinaryZippedPath -ItemType Directory -ErrorAction Stop | Out-Null&#10;        Write-Host &quot;Created rawBinaryZipped folder at $rawBinaryZippedPath&quot;&#10;    } else {&#10;        Write-Host &quot;rawBinaryZipped folder already exists at $rawBinaryZippedPath&quot;&#10;    }&#10;&#10;    # Compress bin folder to ZIP&#10;    $zipFile = Join-Path $rawBinaryZippedPath &quot;bin.zip&quot;&#10;&#10;    if (Test-Path $zipFile) { Remove-Item $zipFile -Force }&#10;    try {&#10;        Compress-Archive -Path (Join-Path $binPath '*') -DestinationPath $zipFile -Force&#10;        Write-Host &quot;ZIP archive created at $zipFile&quot;&#10;    }&#10;    catch {&#10;        Write-CustomError &quot;Failed to create ZIP archive.&quot; $_.Exception.Message&#10;        exit 1&#10;    }&#10;&#10;    # Create SHA256 file for ZIP archive&#10;    function SHA256File {&#10;        param(&#10;            [string]$filePath&#10;        )&#10;        try {&#10;            $hashObj = Get-FileHash -Algorithm SHA256 -Path $filePath&#10;            $shaFile = &quot;$filePath.sha256&quot;&#10;            $content = @&quot;&#10;Algorithm : SHA256&#10;Hash      : $($hashObj.Hash)&#10;&quot;@&#10;            Set-Content -Path $shaFile -Value $content -Encoding UTF8&#10;            Write-Host &quot;SHA256 file created: $shaFile&quot;&#10;        }&#10;        catch {&#10;            Write-CustomError &quot;Failed to create SHA256 file for $filePath.&quot; $_.Exception.Message&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    SHA256File -filePath $zipFile&#10;&#10;    Write-Host &quot;All done.&quot;&#10;&#10;} catch {&#10;    Write-CustomError &quot;Unexpected error occurred.&quot; $_.Exception.Message&#10;    exit 1&#10;}&#10;" />
              <option name="updatedContent" value="$debug = $false&#10;&#10;function Write-CustomError {&#10;    param(&#10;        [string]$Message,&#10;        [string]$Details = &quot;&quot;&#10;    )&#10;    Write-Host $Message -ForegroundColor Red&#10;    if ($debug -and $Details) {&#10;        Write-Host $Details -ForegroundColor DarkRed&#10;    }&#10;}&#10;&#10;try {&#10;    # Move one directory up&#10;    Set-Location ..&#10;&#10;    $binPath = Join-Path (Join-Path (Get-Location) &quot;pyCTools&quot;) &quot;bin&quot;&#10;&#10;    if (-not (Test-Path $binPath -PathType Container)) {&#10;        $binPath = Read-Host &quot;bin folder not found. [Have you executed 'compilerHelper.ps1'?] =&gt; Please enter the full path to the bin folder&quot;&#10;        if (-not (Test-Path $binPath -PathType Container)) {&#10;            Write-CustomError &quot;Provided bin path does not exist or is not a directory.&quot;&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    # Validate bin structure&#10;    $x64Path = Join-Path $binPath &quot;x64&quot;&#10;    $x86Path = Join-Path $binPath &quot;x86&quot;&#10;&#10;    if (-not (Test-Path $x64Path -PathType Container)) {&#10;        Write-CustomError &quot;x64 folder is missing inside bin.&quot;&#10;        exit 1&#10;    }&#10;    if (-not (Test-Path $x86Path -PathType Container)) {&#10;        Write-CustomError &quot;x86 folder is missing inside bin.&quot;&#10;        exit 1&#10;    }&#10;&#10;    $types = @(&quot;dll&quot;, &quot;exp&quot;, &quot;lib&quot;, &quot;obj&quot;)&#10;&#10;    $x64Files = @{}&#10;    $x86Files = @{}&#10;&#10;    foreach ($ext in $types) {&#10;        $x64Files[$ext] = Get-ChildItem -Path $x64Path -Filter &quot;*.$ext&quot; -File | Select-Object -ExpandProperty Name&#10;        $x86Files[$ext] = Get-ChildItem -Path $x86Path -Filter &quot;*.$ext&quot; -File | Select-Object -ExpandProperty Name&#10;    }&#10;&#10;    foreach ($ext in $types) {&#10;        if ($x64Files[$ext].Count -ne $x86Files[$ext].Count) {&#10;            Write-CustomError &quot;Mismatch in number of *.$ext files between x64 and x86 folders.&quot;&#10;            Write-Host &quot;  - x64 count: $($x64Files[$ext].Count), x86 count: $($x86Files[$ext].Count)&quot; -ForegroundColor Red&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    foreach ($ext in $types) {&#10;        $x64BaseNames = $x64Files[$ext] | ForEach-Object { [IO.Path]::GetFileNameWithoutExtension($_) }&#10;        $x86BaseNames = $x86Files[$ext] | ForEach-Object { [IO.Path]::GetFileNameWithoutExtension($_) }&#10;&#10;        if ($ext -eq &quot;dll&quot;) {&#10;            $x64BaseNames = $x64BaseNames | ForEach-Object { $_ -replace &quot;_x64$&quot;, &quot;&quot; }&#10;            $x86BaseNames = $x86BaseNames | ForEach-Object { $_ -replace &quot;_x86$&quot;, &quot;&quot; }&#10;        }&#10;&#10;        $x64BaseNames = $x64BaseNames | Sort-Object&#10;        $x86BaseNames = $x86BaseNames | Sort-Object&#10;&#10;        if (($x64BaseNames -join ',') -ne ($x86BaseNames -join ',')) {&#10;            Write-CustomError &quot;Filenames mismatch in *.$ext files between x64 and x86 folders.&quot;&#10;            Write-Host &quot;  - x64: $($x64BaseNames -join ', ')&quot; -ForegroundColor Red&#10;            Write-Host &quot;  - x86: $($x86BaseNames -join ', ')&quot; -ForegroundColor Red&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    foreach ($folderInfo in @(@{Path=$x64Path; Name=&quot;x64&quot;}, @{Path=$x86Path; Name=&quot;x86&quot;})) {&#10;        $dllFiles = Get-ChildItem -Path $folderInfo.Path -Filter &quot;*.dll&quot; -File&#10;        foreach ($dll in $dllFiles) {&#10;            if (-not $dll.Name.ToLower().Contains($folderInfo.Name.ToLower())) {&#10;                Write-CustomError &quot;DLL file '$($dll.Name)' in folder '$($folderInfo.Name)' does NOT contain the folder name.&quot;&#10;                exit 1&#10;            }&#10;        }&#10;    }&#10;&#10;    Write-Host &quot;bin folder validated successfully.&quot;&#10;&#10;    # Create dist/rawBinaryZipped folder if not exists&#10;    $distRoot = Join-Path (Split-Path (Split-Path $binPath -Parent) -Parent) &quot;dist&quot;&#10;    $rawBinaryZippedPath = Join-Path $distRoot &quot;rawBinaryZipped&quot;&#10;&#10;    if (-not (Test-Path $rawBinaryZippedPath)) {&#10;        New-Item -Path $rawBinaryZippedPath -ItemType Directory -ErrorAction Stop | Out-Null&#10;        Write-Host &quot;Created rawBinaryZipped folder at $rawBinaryZippedPath&quot;&#10;    } else {&#10;        Write-Host &quot;rawBinaryZipped folder already exists at $rawBinaryZippedPath&quot;&#10;    }&#10;&#10;    # Compress bin folder to ZIP&#10;    $zipFile = Join-Path $rawBinaryZippedPath &quot;bin.zip&quot;&#10;&#10;    if (Test-Path $zipFile) { Remove-Item $zipFile -Force }&#10;    try {&#10;        Compress-Archive -Path (Join-Path $binPath '*') -DestinationPath $zipFile -Force&#10;        Write-Host &quot;ZIP archive created at $zipFile&quot;&#10;    }&#10;    catch {&#10;        Write-CustomError &quot;Failed to create ZIP archive.&quot; $_.Exception.Message&#10;        exit 1&#10;    }&#10;&#10;    # Create SHA256 file for ZIP archive&#10;    function SHA256File {&#10;        param(&#10;            [string]$filePath&#10;        )&#10;        try {&#10;            $hashObj = Get-FileHash -Algorithm SHA256 -Path $filePath&#10;            $shaFile = &quot;$filePath.sha256&quot;&#10;            $content = @&quot;&#10;Algorithm : SHA256&#10;Hash      : $($hashObj.Hash)&#10;&quot;@&#10;            Set-Content -Path $shaFile -Value $content -Encoding UTF8&#10;            Write-Host &quot;SHA256 file created: $shaFile&quot;&#10;        }&#10;        catch {&#10;            Write-CustomError &quot;Failed to create SHA256 file for $filePath.&quot; $_.Exception.Message&#10;            exit 1&#10;        }&#10;    }&#10;&#10;    SHA256File -filePath $zipFile&#10;&#10;    Write-Host &quot;All done.&quot;&#10;&#10;} catch {&#10;    Write-CustomError &quot;Unexpected error occurred.&quot; $_.Exception.Message&#10;    exit 1&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tool/release.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tool/release.md" />
              <option name="updatedContent" value="# **pyCTools Release - {RELEASE_TITLE}**&#10;&#10;---&#10;&#10;### Installation of v{VERSION}&#10;Here is the pip command:&#10;```&#10;pip install https://github.com/DefinetlyNotAI/PyCTools/releases/download/{TAG_NAME}/{WHEEL_FILENAME}&#10;```&#10;&#10;---&#10;&#10;{RELEASE_DESCRIPTION}&#10;&#10;**Highlights:**&#10;&#10;* **{HIGHLIGHT_1}:** {HIGHLIGHT_1_DESCRIPTION}&#10;* **{HIGHLIGHT_2}:** {HIGHLIGHT_2_DESCRIPTION}&#10;* **{HIGHLIGHT_3}:** {HIGHLIGHT_3_DESCRIPTION}&#10;* **{HIGHLIGHT_4}:** {HIGHLIGHT_4_DESCRIPTION}&#10;* **{HIGHLIGHT_5}:** {HIGHLIGHT_5_DESCRIPTION}&#10;&#10;{ADDITIONAL_NOTES}&#10;&#10;---&#10;&#10;&gt; [!IMPORTANT]&#10;&gt; ## Attached will be a ZIP file that contains the built DLL's required by the python scripts, &#10;&gt; YOU MUST keep the DLL structure the same: `dist/{architecture_type}/{name}_{architecture_type}.dll`&#10;&gt;&#10;&gt; You will still find the other generated files if you want to play around with them, attached is also the ZIP's hash if you want to check the validity&#10;&gt;&#10;&gt; This supports Windows - both the `x86` (32-bit) and `x64` (64-bit) architecture, and the python wrappers also auto-detect the required architecture to use for your system, so as long as the dist is available, all is good&#10;&gt;&#10;&gt; You can place the `dist` folder in the same directory as the Python library.&#10;&#10;&gt; [!TIP]&#10;&gt; You can also just run the [`tool/compilerHelper.ps1`](https://github.com/DefinetlyNotAI/PyCTools/blob/main/tool/compilerHelper.ps1) tool where as long as you have the `cl.exe` from Microsoft Visual Studio `MSVC` toolchain.&#10;&gt;&#10;&gt; You can just check the source code of the `ps1` tool for the paths it checks for the files!&#10;&#10;---&#10;&#10;| File Name         | Description                                             | Notes                                                                 |&#10;|-------------------|---------------------------------------------------------|-----------------------------------------------------------------------|&#10;| `dist.zip`        | Compressed archive containing required binaries         | Uses ZIP compression. Contains all DLLs needed for the Python wrapper |&#10;| `dist.zip.sha256` | SHA-256 hash file for verifying `dist.zip` integrity    | Ensure file hasn't been tampered with or corrupted                    |&#10;| `{WHEEL_FILENAME}` | WHL File for pip to install the library                | Allows easy pip installation                                         |&#10;&#10;---&#10;&#10;**Full Changelog**: https://github.com/DefinetlyNotAI/PyCTools/compare/{PREVIOUS_TAG}...{TAG_NAME}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tool/setup.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tool/setup.md" />
              <option name="updatedContent" value="# Python Scripts Documentation: Package Building for PyCTools&#10;&#10;---&#10;&#10;## Overview&#10;&#10;These Python scripts handle the build process for the PyCTools package:&#10;&#10;1. `setupHelper.py`: A helper script that:&#10;   - Builds a wheel distribution package&#10;   - Cleans up temporary build files&#10;   - Organizes wheel files into a structured directory&#10;   - Provides guidance for testing and installation&#10;&#10;2. `setup.py`: The package configuration file that:&#10;   - Defines package metadata and structure&#10;   - Includes DLLs from bin directory in the package&#10;   - Validates binary files exist before building&#10;   - **IMPORTANT**: This file should NOT be run directly!&#10;&#10;---&#10;&#10;## Prerequisites&#10;&#10;* Python 3.6 or higher&#10;* The `build` package installed (`pip install build`)&#10;* The `wheel` package installed (`pip install wheel`)&#10;* The `setuptools` package installed (`pip install setuptools`)&#10;* A properly configured project structure with compiled binaries in the bin folder&#10;* `compilerHelper.ps1` must have been executed previously to create the bin directory&#10;&#10;---&#10;&#10;## Script Breakdown: setupHelper.py&#10;&#10;### Helper Functions&#10;&#10;#### `get_version()`&#10;* Extracts the version string from `pyCTools/__init__.py`.&#10;* Returns: The version number of the PyCTools package.&#10;* Exits with error if VERSION string cannot be found or file cannot be read.&#10;&#10;#### `success_finale(whl_filename_, version_)`&#10;* Outputs completion messages and instructions for next steps.&#10;* Parameters:&#10;  * `whl_filename_`: Name of the wheel file that was built&#10;  * `version_`: Version of the package&#10;* Prints testing instructions, local installation commands, and GitHub release instructions.&#10;&#10;#### `get_latest_wheel(dist_dir, package_name)`&#10;* Finds the most recently modified wheel file matching the package name.&#10;* Parameters:&#10;  * `dist_dir`: Directory to search for wheel files&#10;  * `package_name`: Base name of the package&#10;* Returns: Path to the most recent wheel file.&#10;* Exits if no wheel files are found.&#10;&#10;#### `cleanup()`&#10;* Removes build artifacts and organizes wheel files:&#10;  * Removes `./pyCTools.egg-info/` directory&#10;  * Removes `./build/` directory&#10;  * Removes `./pyCTools/dist/` directory&#10;  * Creates `./dist/wheels/` if it doesn't exist&#10;  * Moves wheel files from `./dist/` to `./dist/wheels/`&#10;&#10;### Main Script Logic&#10;&#10;1. Changes to the parent directory of the script.&#10;2. Runs `python -m build --wheel` as a subprocess to build the wheel package.&#10;3. Cleans up temporary files with `cleanup()`.&#10;4. Gets the path to the latest wheel file.&#10;5. Displays success messages and usage instructions.&#10;&#10;---&#10;&#10;## Script Breakdown: setup.py&#10;&#10;&gt; ** WARNING: DO NOT RUN THIS FILE DIRECTLY!** &#10;&gt; &#10;&gt; Always use `setupHelper.py` or the Python build system (`python -m build`). Direct execution of setup.py is deprecated.&#10;&#10;### Helper Functions&#10;&#10;#### `check_bin_exists(bin_path)`&#10;* Validates that the bin directory exists with required DLL files.&#10;* Parameters:&#10;  * `bin_path`: Path to the bin directory&#10;* Checks that both x86 and x64 subfolders exist with DLL files.&#10;* Exits with error if validation fails.&#10;&#10;#### `output_dir_init()`&#10;* Creates the output directory structure for the wheel.&#10;* Returns: Path to the output directory.&#10;* Exits if directory creation fails.&#10;&#10;#### `print_separator(title)`&#10;* Utility function to print a separator line with optional title.&#10;&#10;#### `get_version()`&#10;* Extracts version from `pyCTools/__init__.py`.&#10;* Returns: Version string.&#10;* Exits if VERSION string cannot be found or file cannot be read.&#10;&#10;### Main Script Logic&#10;&#10;1. Extracts version information from `__init__.py`.&#10;2. Validates binary files exist in bin directory.&#10;3. Creates output directory structure.&#10;4. Configures package with metadata and file inclusion rules:&#10;   * Package name, version, author information&#10;   * Includes DLL files from bin/x86 and bin/x64&#10;   * Sets output directories for distribution files&#10;&#10;---&#10;&#10;## How to Use&#10;&#10;### Using setupHelper.py&#10;&#10;1. Ensure you've run `compilerHelper.ps1` to create the bin folder with DLL files.&#10;&#10;2. Navigate to the `tool` directory in your terminal:&#10;   ```&#10;   cd tool&#10;   ```&#10;&#10;3. Run the setupHelper script:&#10;   ```&#10;   python setupHelper.py&#10;   ```&#10;&#10;4. The script will:&#10;   - Build a wheel package&#10;   - Clean up build artifacts&#10;   - Organize the wheel file into `dist/wheels/`&#10;   - Provide instructions for testing and installation&#10;&#10;5. Follow the displayed instructions to:&#10;   - Test in a virtual environment&#10;   - Install locally&#10;   - Prepare for GitHub release&#10;&#10;### About setup.py&#10;&#10;* **DO NOT** run setup.py directly! This is deprecated practice.&#10;* The setup.py file should only be used indirectly through:&#10;  - The `setupHelper.py` script (recommended)&#10;  - The Python build system (`python -m build`)&#10;* This file defines the package structure and metadata but is not meant to be executed directly.&#10;&#10;---&#10;&#10;## Example Output&#10;&#10;```&#10;================================================================================&#10;SETUP SCRIPT OUTPUT&#10;================================================================================&#10;...setup output...&#10;================================================================================&#10;&#10;[*] Removed ./pyCTools.egg-info/&#10;[*] Removed ./build/&#10;[*] Moved ./dist/pyctools-1.0.0-py3-none-any.whl to ./dist/wheels/pyctools-1.0.0-py3-none-any.whl&#10;[*] Found wheel file successfully&#10;&#10;[*] Completed setup.py execution.&#10;        Suggested action: Run 'distributionHelper.ps1' to create the distribution package for github releases.&#10;        Suggested action: Execute the following to test in VENV:&#10;                python -m venv dist/venv_test&#10;                dist\venv_test\Scripts\Activate.ps1&#10;                python -m pip install --upgrade pip&#10;                pip install dist/wheels/pyctools-1.0.0-py3-none-any.whl&#10;                # Do whatever you want here and run any script that uses the library&#10;                deactivate&#10;                Remove-Item -Recurse -Force dist\venv_test&#10;&#10;[*] For local installation, run:&#10;        cd ..&#10;        python -m pip install dist/wheels/pyctools-1.0.0-py3-none-any.whl&#10;[*] If you place the WHL file on the GitHub releases page, users can download it and install it with:&#10;        pip install https://github.com/DefinetlyNotAI/PyCTools/releases/download/1.0.0/pyctools-1.0.0-py3-none-any.whl&#10;        &gt; Assuming the version[1.0.0] entered earlier is the exact same as the tag release.&#10;```&#10;&#10;---&#10;&#10;## Notes&#10;&#10;* Always run `compilerHelper.ps1` before building the package to ensure DLL files are available.&#10;* The wheel file is moved to `dist/wheels/` for better organization.&#10;* If multiple wheel files are found, the most recently modified one is selected.&#10;* Setup validation ensures proper directory structure and presence of required files.&#10;* The package includes both x86 and x64 DLL files, making it compatible with both architectures.&#10;* **NEVER** run setup.py directly as this approach is deprecated and may not work correctly.&#10;&#10;---&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tool/setupHelper.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tool/setupHelper.py" />
              <option name="originalContent" value="import os&#10;import pathlib&#10;import re&#10;import shutil&#10;import subprocess&#10;import sys&#10;&#10;&#10;def get_version() -&gt; str:&#10;    try:&#10;        here = os.path.abspath(os.path.dirname(__file__))&#10;        init_path = os.path.join(here, &quot;..&quot;, &quot;pyCTools&quot;, &quot;__init__.py&quot;)&#10;        version_regex = r'^VERSION\s*=\s*[\'&quot;]([^\'&quot;]*)[\'&quot;]'&#10;&#10;        with open(init_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            content = f.read()&#10;        match = re.search(version_regex, content, re.MULTILINE)&#10;        if match:&#10;            return match.group(1)&#10;        else:&#10;            sys.exit(&quot;[x] Could not find VERSION string in pyCTools/__init__.py&quot;)&#10;    except Exception as err:&#10;        sys.exit(f&quot;[x] Error reading version from __init__.py: {err}\n&quot;)&#10;&#10;&#10;def success_finale(whl_filename_: str, version_: str):&#10;    # Complete the setup process and provide instructions on what to do next&#10;    print(&quot;\033[0m\n[*] Completed setup.py execution.&quot;)&#10;    if not os.path.isfile(&quot;dist/rawBinaryZipped/bin.zip&quot;):&#10;        print(&#10;            &quot;        Suggested action: Run 'distributionHelper.ps1' to create the distribution package for github releases.&quot;&#10;        )&#10;    print(&#10;        &quot;        Suggested action: Execute the following to test in VENV:\n\033[96m&quot;&#10;        &quot;                python -m venv dist/venv_test\n&quot;&#10;        &quot;                dist\\venv_test\\Scripts\\Activate.ps1\n&quot;&#10;        &quot;                python -m pip install --upgrade pip\n&quot;&#10;        f&quot;                pip install dist/wheels/{whl_filename_}\n&quot;&#10;        &quot;                # Do whatever you want here and run any script that uses the library\n&quot;&#10;        &quot;                deactivate\n&quot;&#10;        &quot;                Remove-Item -Recurse -Force dist\\venv_test\n\033[0m&quot;&#10;    )&#10;&#10;    print(&quot;[*] For local installation, run:&quot;)&#10;    print(f&quot;        \033[96mpython -m pip install dist/wheels/{whl_filename_}\033[0m&quot;)&#10;    print(&quot;[*] If you place the WHL file on the GitHub releases page, users can download it and install it with:&quot;)&#10;    print(&#10;        f&quot;        \033[96mpip install https://github.com/DefinetlyNotAI/PyCTools/releases/download/{version_}/{whl_filename_}\033[0m&quot;&#10;    )&#10;    print(f&quot;        &gt; Assuming the version[{version_}] entered earlier is the exact same as the tag release.\n&quot;)&#10;&#10;&#10;def get_latest_wheel(dist_dir: str, package_name: str) -&gt; pathlib.Path:&#10;    dist_path = pathlib.Path(dist_dir)&#10;    pattern = f&quot;{package_name}-*.whl&quot;&#10;    wheel_files = sorted(&#10;        dist_path.glob(pattern),&#10;        key=lambda p: p.stat().st_mtime,&#10;        reverse=True&#10;    )&#10;    if not wheel_files:&#10;        sys.exit(f&quot;[x] No wheel files matching '{pattern}' found in {dist_dir}??\n&quot;)&#10;&#10;    if len(wheel_files) != 1:&#10;        print(&quot;[*] Multiple wheel files found - selecting the most recent one\n&quot;)&#10;    print(f&quot;[*] Found wheel file successfully\n&quot;)&#10;    return wheel_files[0]&#10;&#10;&#10;def cleanup():&#10;    # Remove ./pyCTools.egg-info/&#10;    egg_info = pathlib.Path('./pyCTools.egg-info')&#10;    if egg_info.exists() and egg_info.is_dir():&#10;        shutil.rmtree(egg_info)&#10;        print('[*] Removed ./pyCTools.egg-info/')&#10;&#10;    # Remove ./build/&#10;    build_dir = pathlib.Path('./build')&#10;    if build_dir.exists() and build_dir.is_dir():&#10;        shutil.rmtree(build_dir)&#10;        print('[*] Removed ./build/')&#10;&#10;    # Remove ./pyCTools/dist/&#10;    pyctools_dist = pathlib.Path('./pyCTools/dist')&#10;    if pyctools_dist.exists() and pyctools_dist.is_dir():&#10;        shutil.rmtree(pyctools_dist)&#10;        print('[*] Removed ./pyCTools/dist/')&#10;&#10;    # Ensure ./dist/wheels/ exists&#10;    dist_dir = pathlib.Path('./dist')&#10;    wheels_dir = dist_dir / 'wheels'&#10;    wheels_dir.mkdir(parents=True, exist_ok=True)&#10;&#10;    # Move any .whl files in ./dist to ./dist/wheels/&#10;    for whl_file in dist_dir.glob('*.whl'):&#10;        target = wheels_dir / whl_file.name&#10;        shutil.move(str(whl_file), str(target))&#10;        print(f'[*] Moved {whl_file} to {target}')&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Change to the script's directory&#10;    os.chdir(&quot;..&quot;)&#10;    # Start the setup process live&#10;    process = subprocess.Popen(&#10;        [sys.executable, &quot;-m&quot;, &quot;build&quot;, &quot;--wheel&quot;],&#10;        stdout=sys.stdout,&#10;        stderr=sys.stderr,&#10;    )&#10;    # Wait for the process to complete, quit if it fails, cleanup either way&#10;    exit_code = process.wait()&#10;    cleanup()&#10;    if exit_code != 0:&#10;        sys.exit(1)&#10;&#10;    # Get the latest wheel file&#10;    whl_filename = get_latest_wheel(&quot;dist/wheels&quot;, &quot;pyctools&quot;)&#10;    whl_filename = str(whl_filename).replace(&quot;\\&quot;, &quot;/&quot;)&#10;    # Print success message and instructions&#10;    success_finale(whl_filename_=os.path.basename(str(whl_filename).replace(&quot;\\&quot;, &quot;/&quot;)), version_=get_version())&#10;" />
              <option name="updatedContent" value="import os&#10;import pathlib&#10;import re&#10;import shutil&#10;import subprocess&#10;import sys&#10;&#10;&#10;def get_version() -&gt; str:&#10;    try:&#10;        here = os.path.abspath(os.path.dirname(__file__))&#10;        init_path = os.path.join(here, &quot;..&quot;, &quot;pyCTools&quot;, &quot;__init__.py&quot;)&#10;        version_regex = r'^VERSION\s*=\s*[\'&quot;]([^\'&quot;]*)[\'&quot;]'&#10;&#10;        with open(init_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            content = f.read()&#10;        match = re.search(version_regex, content, re.MULTILINE)&#10;        if match:&#10;            return match.group(1)&#10;        else:&#10;            sys.exit(&quot;[x] Could not find VERSION string in pyCTools/__init__.py&quot;)&#10;    except Exception as err:&#10;        sys.exit(f&quot;[x] Error reading version from __init__.py: {err}\n&quot;)&#10;&#10;&#10;def success_finale(whl_filename_: str, version_: str):&#10;    # Complete the setup process and provide instructions on what to do next&#10;    print(&quot;\033[0m\n[*] Completed setup.py execution.&quot;)&#10;    if not os.path.isfile(&quot;dist/rawBinaryZipped/bin.zip&quot;):&#10;        print(&#10;            &quot;        Suggested action: Run 'distributionHelper.ps1' to create the distribution package for github releases.&quot;&#10;        )&#10;    print(&#10;        &quot;        Suggested action: Execute the following to test in VENV:\n\033[96m&quot;&#10;        &quot;                python -m venv dist/venv_test\n&quot;&#10;        &quot;                dist\\venv_test\\Scripts\\Activate.ps1\n&quot;&#10;        &quot;                python -m pip install --upgrade pip\n&quot;&#10;        f&quot;                pip install dist/wheels/{whl_filename_}\n&quot;&#10;        &quot;                # Do whatever you want here and run any script that uses the library\n&quot;&#10;        &quot;                deactivate\n&quot;&#10;        &quot;                Remove-Item -Recurse -Force dist\\venv_test\n\033[0m&quot;&#10;    )&#10;&#10;    print(&quot;[*] For local installation, run:&quot;)&#10;    print(f&quot;        \033[96mpython -m pip install dist/wheels/{whl_filename_}\033[0m&quot;)&#10;    print(&quot;[*] If you place the WHL file on the GitHub releases page, users can download it and install it with:&quot;)&#10;    print(&#10;        f&quot;        \033[96mpip install https://github.com/DefinetlyNotAI/PyCTools/releases/download/{version_}/{whl_filename_}\033[0m&quot;&#10;    )&#10;    print(f&quot;        &gt; Assuming the version[{version_}] entered earlier is the exact same as the tag release.\n&quot;)&#10;&#10;&#10;def get_latest_wheel(dist_dir: str, package_name: str) -&gt; pathlib.Path:&#10;    dist_path = pathlib.Path(dist_dir)&#10;    pattern = f&quot;{package_name}-*.whl&quot;&#10;    wheel_files = sorted(&#10;        dist_path.glob(pattern),&#10;        key=lambda p: p.stat().st_mtime,&#10;        reverse=True&#10;    )&#10;    if not wheel_files:&#10;        sys.exit(f&quot;[x] No wheel files matching '{pattern}' found in {dist_dir}??\n&quot;)&#10;&#10;    if len(wheel_files) != 1:&#10;        print(&quot;[*] Multiple wheel files found - selecting the most recent one\n&quot;)&#10;    print(f&quot;[*] Found wheel file successfully\n&quot;)&#10;    return wheel_files[0]&#10;&#10;&#10;def cleanup():&#10;    # Remove ./pyCTools.egg-info/&#10;    egg_info = pathlib.Path('./pyCTools.egg-info')&#10;    if egg_info.exists() and egg_info.is_dir():&#10;        shutil.rmtree(egg_info)&#10;        print('[*] Removed ./pyCTools.egg-info/')&#10;&#10;    # Remove ./build/&#10;    build_dir = pathlib.Path('./build')&#10;    if build_dir.exists() and build_dir.is_dir():&#10;        shutil.rmtree(build_dir)&#10;        print('[*] Removed ./build/')&#10;&#10;    # Remove ./pyCTools/dist/&#10;    pyctools_dist = pathlib.Path('./pyCTools/dist')&#10;    if pyctools_dist.exists() and pyctools_dist.is_dir():&#10;        shutil.rmtree(pyctools_dist)&#10;        print('[*] Removed ./pyCTools/dist/')&#10;&#10;    # Ensure ./dist/wheels/ exists&#10;    dist_dir = pathlib.Path('./dist')&#10;    wheels_dir = dist_dir / 'wheels'&#10;    wheels_dir.mkdir(parents=True, exist_ok=True)&#10;&#10;    # Move any .whl files in ./dist to ./dist/wheels/&#10;    for whl_file in dist_dir.glob('*.whl'):&#10;        target = wheels_dir / whl_file.name&#10;        shutil.move(str(whl_file), str(target))&#10;        print(f'[*] Moved {whl_file} to {target}')&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Change to the script's directory&#10;    os.chdir(&quot;..&quot;)&#10;    # Start the setup process live&#10;    process = subprocess.Popen(&#10;        [sys.executable, &quot;-m&quot;, &quot;build&quot;, &quot;--wheel&quot;],&#10;        stdout=sys.stdout,&#10;        stderr=sys.stderr,&#10;    )&#10;    # Wait for the process to complete, quit if it fails, cleanup either way&#10;    exit_code = process.wait()&#10;    cleanup()&#10;    if exit_code != 0:&#10;        sys.exit(1)&#10;&#10;    # Get the latest wheel file&#10;    whl_filename = get_latest_wheel(&quot;dist/wheels&quot;, &quot;pyctools&quot;)&#10;    whl_filename = str(whl_filename).replace(&quot;\\&quot;, &quot;/&quot;)&#10;    # Print success message and instructions&#10;    success_finale(whl_filename_=os.path.basename(str(whl_filename).replace(&quot;\\&quot;, &quot;/&quot;)), version_=get_version())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>